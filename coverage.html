
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">oracle-etl/cmd/server/main.go (38.1%)</option>
				
				<option value="file1">oracle-etl/internal/adapter/gcs/client.go (46.8%)</option>
				
				<option value="file2">oracle-etl/internal/adapter/gcs/uploader.go (60.0%)</option>
				
				<option value="file3">oracle-etl/internal/adapter/handler/health.go (100.0%)</option>
				
				<option value="file4">oracle-etl/internal/adapter/handler/job.go (94.7%)</option>
				
				<option value="file5">oracle-etl/internal/adapter/handler/oracle.go (100.0%)</option>
				
				<option value="file6">oracle-etl/internal/adapter/handler/status.go (88.5%)</option>
				
				<option value="file7">oracle-etl/internal/adapter/handler/table.go (59.5%)</option>
				
				<option value="file8">oracle-etl/internal/adapter/handler/transport.go (82.4%)</option>
				
				<option value="file9">oracle-etl/internal/adapter/oracle/extractor.go (94.4%)</option>
				
				<option value="file10">oracle-etl/internal/adapter/oracle/mock_repository.go (78.9%)</option>
				
				<option value="file11">oracle-etl/internal/adapter/oracle/pool.go (7.5%)</option>
				
				<option value="file12">oracle-etl/internal/adapter/sse/broadcaster.go (95.5%)</option>
				
				<option value="file13">oracle-etl/internal/adapter/sse/event.go (94.1%)</option>
				
				<option value="file14">oracle-etl/internal/adapter/sse/metrics.go (95.7%)</option>
				
				<option value="file15">oracle-etl/internal/config/config.go (92.0%)</option>
				
				<option value="file16">oracle-etl/internal/domain/extraction.go (5.9%)</option>
				
				<option value="file17">oracle-etl/internal/domain/job.go (61.5%)</option>
				
				<option value="file18">oracle-etl/internal/domain/transport.go (63.2%)</option>
				
				<option value="file19">oracle-etl/internal/errors/errors.go (85.7%)</option>
				
				<option value="file20">oracle-etl/internal/middleware/auth.go (92.7%)</option>
				
				<option value="file21">oracle-etl/internal/middleware/cors.go (100.0%)</option>
				
				<option value="file22">oracle-etl/internal/middleware/logging.go (93.3%)</option>
				
				<option value="file23">oracle-etl/internal/middleware/masking.go (85.7%)</option>
				
				<option value="file24">oracle-etl/internal/middleware/ratelimit.go (83.9%)</option>
				
				<option value="file25">oracle-etl/internal/middleware/recovery.go (45.7%)</option>
				
				<option value="file26">oracle-etl/internal/repository/memory/job_repo.go (98.4%)</option>
				
				<option value="file27">oracle-etl/internal/repository/memory/transport_repo.go (96.1%)</option>
				
				<option value="file28">oracle-etl/internal/resilience/circuit.go (80.7%)</option>
				
				<option value="file29">oracle-etl/internal/resilience/retry.go (78.6%)</option>
				
				<option value="file30">oracle-etl/internal/resilience/shutdown.go (91.5%)</option>
				
				<option value="file31">oracle-etl/internal/usecase/job_service.go (67.4%)</option>
				
				<option value="file32">oracle-etl/internal/usecase/parallel_executor.go (88.7%)</option>
				
				<option value="file33">oracle-etl/internal/usecase/transport_service.go (70.0%)</option>
				
				<option value="file34">oracle-etl/pkg/buffer/config.go (72.2%)</option>
				
				<option value="file35">oracle-etl/pkg/compress/gzip.go (70.0%)</option>
				
				<option value="file36">oracle-etl/pkg/jsonl/encoder.go (92.0%)</option>
				
				<option value="file37">oracle-etl/pkg/pool/worker.go (91.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main은 Oracle ETL API 서버의 진입점입니다
package main

import (
        "context"
        "os"
        "os/signal"
        "strconv"
        "syscall"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/rs/zerolog"

        "oracle-etl/internal/adapter/handler"
        "oracle-etl/internal/adapter/sse"
        "oracle-etl/internal/config"
        "oracle-etl/internal/middleware"
        "oracle-etl/internal/repository/memory"
        "oracle-etl/internal/usecase"
)

const (
        // defaultConfigPath는 기본 설정 파일 경로입니다
        defaultConfigPath = "config.yaml"
)

func main() <span class="cov0" title="0">{
        // 로거 초기화 (JSON 포맷, UTC 타임스탬프)
        logger := zerolog.New(os.Stdout).
                With().
                Timestamp().
                Caller().
                Logger()

        zerolog.TimeFieldFormat = time.RFC3339

        // 설정 로드
        configPath := os.Getenv("CONFIG_PATH")
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = defaultConfigPath
        }</span>

        <span class="cov0" title="0">cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal().Err(err).Msg("설정 로드 실패")
        }</span>

        // 설정 유효성 검사
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal().Err(err).Msg("설정 유효성 검사 실패")
        }</span>

        <span class="cov0" title="0">logger.Info().
                Str("app", cfg.App.Name).
                Str("version", cfg.App.Version).
                Str("environment", cfg.App.Environment).
                Int("port", cfg.Server.Port).
                Msg("서버 시작 준비")

        // SSE Broadcaster 초기화
        broadcaster := sse.NewBroadcaster()

        // Broadcaster 컨텍스트 (서버 종료 시 함께 종료)
        broadcasterCtx, broadcasterCancel := context.WithCancel(context.Background())
        defer broadcasterCancel()

        // Broadcaster 시작
        go broadcaster.Run(broadcasterCtx)
        logger.Info().Msg("SSE Broadcaster 시작됨")

        // Repository 초기화 (In-Memory)
        transportRepo := memory.NewTransportRepository()
        jobRepo := memory.NewJobRepository()

        // Service 초기화
        transportSvc := usecase.NewTransportService(transportRepo)
        jobSvc := usecase.NewJobService(jobRepo, transportRepo)

        // Fiber 앱 초기화
        app := setupFiber(cfg, logger)

        // 라우트 설정
        setupRoutes(app, cfg, transportSvc, jobSvc, broadcaster)

        // 서버 시작 (goroutine)
        go func() </span><span class="cov0" title="0">{
                addr := ":" + strconv.Itoa(cfg.Server.Port)
                if err := app.Listen(addr); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal().Err(err).Msg("서버 시작 실패")
                }</span>
        }()

        <span class="cov0" title="0">logger.Info().
                Int("port", cfg.Server.Port).
                Msg("서버 시작됨")

        // Graceful Shutdown 대기
        waitForShutdown(app, logger, broadcasterCancel)</span>
}

// setupFiber는 Fiber 앱을 설정합니다
func setupFiber(cfg *config.Config, logger zerolog.Logger) *fiber.App <span class="cov10" title="5">{
        readTimeout, _ := time.ParseDuration(cfg.Server.ReadTimeout)
        writeTimeout, _ := time.ParseDuration(cfg.Server.WriteTimeout)

        app := fiber.New(fiber.Config{
                AppName:      cfg.App.Name,
                ReadTimeout:  readTimeout,
                WriteTimeout: writeTimeout,
                // JSON 에러 핸들러
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov1" title="1">{
                        code := fiber.StatusInternalServerError
                        if e, ok := err.(*fiber.Error); ok </span><span class="cov1" title="1">{
                                code = e.Code
                        }</span>
                        <span class="cov1" title="1">return c.Status(code).JSON(fiber.Map{
                                "code":    "ERROR",
                                "message": err.Error(),
                        })</span>
                },
        })

        // 미들웨어 적용
        <span class="cov10" title="5">app.Use(middleware.NewRecoveryMiddleware(logger))
        app.Use(middleware.NewLoggingMiddleware(logger))

        return app</span>
}

// setupRoutes는 API 라우트를 설정합니다
func setupRoutes(app *fiber.App, cfg *config.Config, transportSvc *usecase.TransportService, jobSvc *usecase.JobService, broadcaster *sse.Broadcaster) <span class="cov7" title="3">{
        // Handlers 초기화
        healthHandler := handler.NewHealthHandler(cfg.App.Version)
        transportHandler := handler.NewTransportHandler(transportSvc, jobSvc)
        jobHandler := handler.NewJobHandler(jobSvc)
        statusHandler := handler.NewStatusHandler(broadcaster)

        // API 그룹
        api := app.Group("/api")

        // Health
        api.Get("/health", healthHandler.Check)

        // Transport CRUD
        api.Post("/transports", transportHandler.Create)
        api.Get("/transports", transportHandler.List)
        api.Get("/transports/:id", transportHandler.GetByID)
        api.Delete("/transports/:id", transportHandler.Delete)
        api.Post("/transports/:id/execute", transportHandler.Execute)

        // Transport 실시간 상태 (SSE)
        api.Get("/transports/:id/status", statusHandler.GetStatus)

        // Job 조회
        api.Get("/jobs", jobHandler.List)
        api.Get("/jobs/:id", jobHandler.GetByID)
}</span>

// waitForShutdown은 종료 시그널을 대기하고 graceful shutdown을 수행합니다
func waitForShutdown(app *fiber.App, logger zerolog.Logger, broadcasterCancel context.CancelFunc) <span class="cov0" title="0">{
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        &lt;-quit
        logger.Info().Msg("종료 시그널 수신, 서버 종료 중...")

        // SSE Broadcaster 종료
        broadcasterCancel()
        logger.Info().Msg("SSE Broadcaster 종료됨")

        // 진행 중인 요청을 완료하기 위한 타임아웃
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := app.ShutdownWithContext(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("서버 종료 중 오류 발생")
        }</span>

        <span class="cov0" title="0">logger.Info().Msg("서버 종료 완료")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package gcs는 Google Cloud Storage 클라이언트 및 업로드 기능을 제공합니다.
// 스트리밍 업로드, resumable 업로드, 진행률 추적을 지원합니다.
package gcs

import (
        "context"
        "errors"
        "fmt"
        "io"
        "time"

        "cloud.google.com/go/storage"
        "google.golang.org/api/option"
)

// 기본 상수 정의
const (
        // DefaultChunkSize는 resumable 업로드의 기본 청크 크기입니다 (16MB)
        DefaultChunkSize = 16 * 1024 * 1024

        // DefaultTimeout은 GCS 작업의 기본 타임아웃입니다
        DefaultTimeout = 10 * time.Minute
)

// GCSConfig는 GCS 클라이언트 설정을 정의합니다
type GCSConfig struct {
        ProjectID       string        `mapstructure:"project_id"`       // GCP 프로젝트 ID
        BucketName      string        `mapstructure:"bucket_name"`      // 대상 버킷 이름
        CredentialsFile string        `mapstructure:"credentials_file"` // 서비스 계정 JSON 파일 경로
        ChunkSize       int           `mapstructure:"chunk_size"`       // resumable 업로드 청크 크기
        Timeout         time.Duration `mapstructure:"timeout"`          // 작업 타임아웃
}

// Validate는 설정의 유효성을 검사합니다
func (c *GCSConfig) Validate() error <span class="cov5" title="4">{
        if c.ProjectID == "" </span><span class="cov1" title="1">{
                return errors.New("GCS ProjectID가 설정되지 않음")
        }</span>
        <span class="cov4" title="3">if c.BucketName == "" </span><span class="cov1" title="1">{
                return errors.New("GCS BucketName이 설정되지 않음")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// ApplyDefaults는 기본값을 적용합니다
func (c *GCSConfig) ApplyDefaults() <span class="cov9" title="12">{
        if c.ChunkSize &lt;= 0 </span><span class="cov9" title="12">{
                c.ChunkSize = DefaultChunkSize
        }</span>
        <span class="cov9" title="12">if c.Timeout &lt;= 0 </span><span class="cov9" title="12">{
                c.Timeout = DefaultTimeout
        }</span>
}

// Client는 GCS 클라이언트 인터페이스입니다
type Client interface {
        // Ping은 GCS 연결을 테스트합니다
        Ping(ctx context.Context) error

        // NewWriter는 객체에 쓰기 위한 Writer를 생성합니다
        NewWriter(ctx context.Context, objectPath string) (io.WriteCloser, error)

        // ObjectPath는 표준 객체 경로를 생성합니다
        ObjectPath(transportID, jobVersion, tableName string) string

        // FullGCSPath는 전체 GCS URI를 반환합니다
        FullGCSPath(transportID, jobVersion, tableName string) string

        // BucketName은 버킷 이름을 반환합니다
        BucketName() string

        // Close는 클라이언트를 닫습니다
        Close() error
}

// gcsClient는 실제 GCS 클라이언트 구현체입니다
type gcsClient struct {
        client     *storage.Client
        bucket     *storage.BucketHandle
        config     GCSConfig
}

// NewClient는 새로운 GCS 클라이언트를 생성합니다
func NewClient(ctx context.Context, config GCSConfig) (Client, error) <span class="cov0" title="0">{
        config.ApplyDefaults()

        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GCS 설정 유효성 검사 실패: %w", err)
        }</span>

        <span class="cov0" title="0">var opts []option.ClientOption
        if config.CredentialsFile != "" </span><span class="cov0" title="0">{
                opts = append(opts, option.WithCredentialsFile(config.CredentialsFile))
        }</span>

        <span class="cov0" title="0">client, err := storage.NewClient(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GCS 클라이언트 생성 실패: %w", err)
        }</span>

        <span class="cov0" title="0">bucket := client.Bucket(config.BucketName)

        return &amp;gcsClient{
                client: client,
                bucket: bucket,
                config: config,
        }, nil</span>
}

// Ping은 GCS 연결을 테스트합니다
func (c *gcsClient) Ping(ctx context.Context) error <span class="cov0" title="0">{
        _, err := c.bucket.Attrs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("GCS 버킷 접근 실패: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewWriter는 객체에 쓰기 위한 Writer를 생성합니다
func (c *gcsClient) NewWriter(ctx context.Context, objectPath string) (io.WriteCloser, error) <span class="cov0" title="0">{
        obj := c.bucket.Object(objectPath)
        writer := obj.NewWriter(ctx)

        // Resumable 업로드를 위한 청크 크기 설정
        writer.ChunkSize = c.config.ChunkSize

        // Content-Type 설정
        writer.ContentType = "application/gzip"
        writer.ContentEncoding = "gzip"

        return writer, nil
}</span>

// ObjectPath는 표준 객체 경로를 생성합니다
// 패턴: {transport_id}/{job_version}/{table_name}.jsonl.gz
func (c *gcsClient) ObjectPath(transportID, jobVersion, tableName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s/%s.jsonl.gz", transportID, jobVersion, tableName)
}</span>

// FullGCSPath는 전체 GCS URI를 반환합니다
// 패턴: gs://{bucket}/{transport_id}/{job_version}/{table_name}.jsonl.gz
func (c *gcsClient) FullGCSPath(transportID, jobVersion, tableName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("gs://%s/%s", c.config.BucketName, c.ObjectPath(transportID, jobVersion, tableName))
}</span>

// BucketName은 버킷 이름을 반환합니다
func (c *gcsClient) BucketName() string <span class="cov0" title="0">{
        return c.config.BucketName
}</span>

// Close는 클라이언트를 닫습니다
func (c *gcsClient) Close() error <span class="cov0" title="0">{
        return c.client.Close()
}</span>

// MockClient는 테스트용 Mock GCS 클라이언트입니다
type MockClient struct {
        config GCSConfig
        closed bool
}

// NewMockClient는 테스트용 Mock 클라이언트를 생성합니다
func NewMockClient(config GCSConfig) Client <span class="cov9" title="11">{
        config.ApplyDefaults()
        return &amp;MockClient{
                config: config,
                closed: false,
        }
}</span>

// Ping은 Mock 연결 테스트입니다 (항상 성공)
func (m *MockClient) Ping(ctx context.Context) error <span class="cov1" title="1">{
        return nil
}</span>

// NewWriter는 Mock Writer를 반환합니다
func (m *MockClient) NewWriter(ctx context.Context, objectPath string) (io.WriteCloser, error) <span class="cov4" title="3">{
        return &amp;mockWriter{}, nil
}</span>

// ObjectPath는 표준 객체 경로를 생성합니다
func (m *MockClient) ObjectPath(transportID, jobVersion, tableName string) string <span class="cov4" title="3">{
        return fmt.Sprintf("%s/%s/%s.jsonl.gz", transportID, jobVersion, tableName)
}</span>

// FullGCSPath는 전체 GCS URI를 반환합니다
func (m *MockClient) FullGCSPath(transportID, jobVersion, tableName string) string <span class="cov1" title="1">{
        return fmt.Sprintf("gs://%s/%s", m.config.BucketName, m.ObjectPath(transportID, jobVersion, tableName))
}</span>

// BucketName은 버킷 이름을 반환합니다
func (m *MockClient) BucketName() string <span class="cov1" title="1">{
        return m.config.BucketName
}</span>

// Close는 Mock 클라이언트를 닫습니다
func (m *MockClient) Close() error <span class="cov1" title="1">{
        m.closed = true
        return nil
}</span>

// mockWriter는 테스트용 Mock io.WriteCloser입니다
type mockWriter struct {
        bytesWritten int64
}

func (w *mockWriter) Write(p []byte) (n int, err error) <span class="cov10" title="13">{
        n = len(p)
        w.bytesWritten += int64(n)
        return n, nil
}</span>

func (w *mockWriter) Close() error <span class="cov4" title="3">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package gcs는 Google Cloud Storage 클라이언트 및 업로드 기능을 제공합니다.
package gcs

import (
        "context"
        "fmt"
        
        "sync/atomic"
        "time"

        "oracle-etl/pkg/compress"
        "oracle-etl/pkg/jsonl"
)

// UploadProgress는 업로드 진행 상황을 나타냅니다
type UploadProgress struct {
        BytesWritten int64     // 압축 후 전송된 바이트 수
        BytesTotal   int64     // 총 바이트 수 (-1이면 알 수 없음)
        RowsWritten  int64     // 기록된 row 수
        StartTime    time.Time // 업로드 시작 시간
        LastUpdate   time.Time // 마지막 업데이트 시간
}

// Percent는 진행률을 반환합니다 (0-100, 알 수 없으면 -1)
func (p UploadProgress) Percent() float64 <span class="cov2" title="2">{
        if p.BytesTotal &lt;= 0 </span><span class="cov1" title="1">{
                return -1
        }</span>
        <span class="cov1" title="1">return float64(p.BytesWritten) / float64(p.BytesTotal) * 100</span>
}

// BytesPerSecond는 전송 속도를 반환합니다
func (p UploadProgress) BytesPerSecond() float64 <span class="cov1" title="1">{
        elapsed := time.Since(p.StartTime).Seconds()
        if elapsed &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return float64(p.BytesWritten) / elapsed</span>
}

// RowsPerSecond는 row 처리 속도를 반환합니다
func (p UploadProgress) RowsPerSecond() float64 <span class="cov0" title="0">{
        elapsed := time.Since(p.StartTime).Seconds()
        if elapsed &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(p.RowsWritten) / elapsed</span>
}

// ProgressCallback는 진행률 콜백 함수 타입입니다
type ProgressCallback func(progress UploadProgress)

// UploadResult는 업로드 완료 결과를 나타냅니다
type UploadResult struct {
        BytesWritten  int64         // 압축 후 전송된 바이트 수
        BytesOriginal int64         // 압축 전 원본 바이트 수
        RowsWritten   int64         // 기록된 row 수
        Duration      time.Duration // 업로드 소요 시간
        ObjectPath    string        // GCS 객체 경로
}

// CompressionRatio는 압축률을 반환합니다 (0.0-1.0)
func (r UploadResult) CompressionRatio() float64 <span class="cov1" title="1">{
        if r.BytesOriginal &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return float64(r.BytesWritten) / float64(r.BytesOriginal)</span>
}

// RowsPerSecond는 row 처리 속도를 반환합니다
func (r UploadResult) RowsPerSecond() float64 <span class="cov1" title="1">{
        if r.Duration &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return float64(r.RowsWritten) / r.Duration.Seconds()</span>
}

// MBPerSecond는 전송 속도 (MB/s)를 반환합니다
func (r UploadResult) MBPerSecond() float64 <span class="cov1" title="1">{
        if r.Duration &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return float64(r.BytesWritten) / (1024 * 1024) / r.Duration.Seconds()</span>
}

// Uploader는 GCS 스트리밍 업로드 인터페이스입니다
type Uploader interface {
        // Upload는 row 슬라이스를 GCS에 업로드합니다
        Upload(ctx context.Context, objectPath string, rows []map[string]interface{}, callback ProgressCallback) (*UploadResult, error)

        // UploadStream은 채널에서 row를 읽어 스트리밍 업로드합니다
        UploadStream(ctx context.Context, objectPath string, rowChan &lt;-chan map[string]interface{}, callback ProgressCallback) (*UploadResult, error)
}

// StreamingUploader는 Uploader 인터페이스의 구현체입니다
type StreamingUploader struct {
        client            Client
        progressInterval  time.Duration // 진행률 콜백 호출 간격
}

// NewStreamingUploader는 새로운 스트리밍 업로더를 생성합니다
func NewStreamingUploader(client Client) Uploader <span class="cov4" title="6">{
        return &amp;StreamingUploader{
                client:           client,
                progressInterval: 100 * time.Millisecond,
        }
}</span>

// Upload는 row 슬라이스를 GCS에 업로드합니다
func (u *StreamingUploader) Upload(ctx context.Context, objectPath string, rows []map[string]interface{}, callback ProgressCallback) (*UploadResult, error) <span class="cov3" title="4">{
        startTime := time.Now()

        // 컨텍스트 취소 확인
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return nil, ctx.Err()</span>
        default:<span class="cov3" title="3"></span>
        }

        // GCS writer 생성
        <span class="cov3" title="3">gcsWriter, err := u.client.NewWriter(ctx, objectPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GCS writer 생성 실패: %w", err)
        }</span>
        <span class="cov3" title="3">defer gcsWriter.Close()

        // 파이프라인: JSONL -&gt; Gzip -&gt; GCS
        gzipWriter := compress.NewGzipWriter(gcsWriter)
        jsonlEncoder := jsonl.NewEncoder(gzipWriter)

        var rowsWritten int64
        lastCallback := time.Now()

        for _, row := range rows </span><span class="cov10" title="105">{
                // 컨텍스트 취소 확인
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        _ = gzipWriter.Close() // 에러 경로에서 정리
                        return nil, ctx.Err()</span>
                default:<span class="cov10" title="105"></span>
                }

                <span class="cov10" title="105">if err := jsonlEncoder.Encode(row); err != nil </span><span class="cov0" title="0">{
                        _ = gzipWriter.Close() // 에러 경로에서 정리
                        return nil, fmt.Errorf("row 인코딩 실패: %w", err)
                }</span>
                <span class="cov10" title="105">atomic.AddInt64(&amp;rowsWritten, 1)

                // 진행률 콜백
                if callback != nil &amp;&amp; time.Since(lastCallback) &gt;= u.progressInterval </span><span class="cov0" title="0">{
                        callback(UploadProgress{
                                BytesWritten: gzipWriter.BytesWritten(),
                                BytesTotal:   -1, // 스트리밍에서는 총량 알 수 없음
                                RowsWritten:  atomic.LoadInt64(&amp;rowsWritten),
                                StartTime:    startTime,
                                LastUpdate:   time.Now(),
                        })
                        lastCallback = time.Now()
                }</span>
        }

        // JSONL 버퍼 플러시
        <span class="cov3" title="3">if err := jsonlEncoder.Flush(); err != nil </span><span class="cov0" title="0">{
                _ = gzipWriter.Close() // 에러 경로에서 정리
                return nil, fmt.Errorf("JSONL 플러시 실패: %w", err)
        }</span>

        // Gzip 스트림 닫기
        <span class="cov3" title="3">if err := gzipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gzip 스트림 닫기 실패: %w", err)
        }</span>

        // 최종 진행률 콜백
        <span class="cov3" title="3">if callback != nil </span><span class="cov1" title="1">{
                callback(UploadProgress{
                        BytesWritten: gzipWriter.BytesWritten(),
                        BytesTotal:   gzipWriter.BytesWritten(),
                        RowsWritten:  atomic.LoadInt64(&amp;rowsWritten),
                        StartTime:    startTime,
                        LastUpdate:   time.Now(),
                })
        }</span>

        <span class="cov3" title="3">return &amp;UploadResult{
                BytesWritten:  gzipWriter.BytesWritten(),
                BytesOriginal: gzipWriter.BytesRead(),
                RowsWritten:   atomic.LoadInt64(&amp;rowsWritten),
                Duration:      time.Since(startTime),
                ObjectPath:    objectPath,
        }, nil</span>
}

// UploadStream은 채널에서 row를 읽어 스트리밍 업로드합니다
func (u *StreamingUploader) UploadStream(ctx context.Context, objectPath string, rowChan &lt;-chan map[string]interface{}, callback ProgressCallback) (*UploadResult, error) <span class="cov1" title="1">{
        startTime := time.Now()

        // GCS writer 생성
        gcsWriter, err := u.client.NewWriter(ctx, objectPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GCS writer 생성 실패: %w", err)
        }</span>
        <span class="cov1" title="1">defer gcsWriter.Close()

        // 파이프라인: JSONL -&gt; Gzip -&gt; GCS
        gzipWriter := compress.NewGzipWriter(gcsWriter)
        jsonlEncoder := jsonl.NewEncoder(gzipWriter)

        var rowsWritten int64
        lastCallback := time.Now()

        for </span><span class="cov8" title="51">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        _ = gzipWriter.Close() // 에러 경로에서 정리
                        return nil, ctx.Err()</span>

                case row, ok := &lt;-rowChan:<span class="cov8" title="51">
                        if !ok </span><span class="cov1" title="1">{
                                // 채널 닫힘 - 업로드 완료
                                if err := jsonlEncoder.Flush(); err != nil </span><span class="cov0" title="0">{
                                        _ = gzipWriter.Close() // 에러 경로에서 정리
                                        return nil, fmt.Errorf("JSONL 플러시 실패: %w", err)
                                }</span>

                                <span class="cov1" title="1">if err := gzipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("gzip 스트림 닫기 실패: %w", err)
                                }</span>

                                // 최종 진행률 콜백
                                <span class="cov1" title="1">if callback != nil </span><span class="cov0" title="0">{
                                        callback(UploadProgress{
                                                BytesWritten: gzipWriter.BytesWritten(),
                                                BytesTotal:   gzipWriter.BytesWritten(),
                                                RowsWritten:  atomic.LoadInt64(&amp;rowsWritten),
                                                StartTime:    startTime,
                                                LastUpdate:   time.Now(),
                                        })
                                }</span>

                                <span class="cov1" title="1">return &amp;UploadResult{
                                        BytesWritten:  gzipWriter.BytesWritten(),
                                        BytesOriginal: gzipWriter.BytesRead(),
                                        RowsWritten:   atomic.LoadInt64(&amp;rowsWritten),
                                        Duration:      time.Since(startTime),
                                        ObjectPath:    objectPath,
                                }, nil</span>
                        }

                        <span class="cov8" title="50">if err := jsonlEncoder.Encode(row); err != nil </span><span class="cov0" title="0">{
                                _ = gzipWriter.Close() // 에러 경로에서 정리
                                return nil, fmt.Errorf("row 인코딩 실패: %w", err)
                        }</span>
                        <span class="cov8" title="50">atomic.AddInt64(&amp;rowsWritten, 1)

                        // 진행률 콜백
                        if callback != nil &amp;&amp; time.Since(lastCallback) &gt;= u.progressInterval </span><span class="cov0" title="0">{
                                callback(UploadProgress{
                                        BytesWritten: gzipWriter.BytesWritten(),
                                        BytesTotal:   -1,
                                        RowsWritten:  atomic.LoadInt64(&amp;rowsWritten),
                                        StartTime:    startTime,
                                        LastUpdate:   time.Now(),
                                })
                                lastCallback = time.Now()
                        }</span>
                }
        }
}

// PipelineUploader는 Oracle 추출과 GCS 업로드를 연결하는 파이프라인입니다
type PipelineUploader struct {
        uploader Uploader
        client   Client
}

// NewPipelineUploader는 새로운 파이프라인 업로더를 생성합니다
func NewPipelineUploader(client Client) *PipelineUploader <span class="cov0" title="0">{
        return &amp;PipelineUploader{
                uploader: NewStreamingUploader(client),
                client:   client,
        }
}</span>

// UploadTable은 테이블 데이터를 GCS에 업로드합니다
func (p *PipelineUploader) UploadTable(ctx context.Context, transportID, jobVersion, tableName string, rows []map[string]interface{}, callback ProgressCallback) (*UploadResult, error) <span class="cov0" title="0">{
        objectPath := p.client.ObjectPath(transportID, jobVersion, tableName)
        return p.uploader.Upload(ctx, objectPath, rows, callback)
}</span>

// UploadTableStream은 테이블 데이터를 스트리밍으로 GCS에 업로드합니다
func (p *PipelineUploader) UploadTableStream(ctx context.Context, transportID, jobVersion, tableName string, rowChan &lt;-chan map[string]interface{}, callback ProgressCallback) (*UploadResult, error) <span class="cov0" title="0">{
        objectPath := p.client.ObjectPath(transportID, jobVersion, tableName)
        return p.uploader.UploadStream(ctx, objectPath, rowChan, callback)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package handler는 HTTP 요청 핸들러를 제공합니다
package handler

import (
        "time"

        "github.com/gofiber/fiber/v2"
)

// HealthHandler는 헬스 체크 엔드포인트 핸들러입니다
type HealthHandler struct {
        version string
}

// HealthResponse는 /api/health 응답 구조체입니다
type HealthResponse struct {
        Status    string    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Version   string    `json:"version"`
}

// NewHealthHandler는 새로운 HealthHandler를 생성합니다
func NewHealthHandler(version string) *HealthHandler <span class="cov10" title="3">{
        return &amp;HealthHandler{
                version: version,
        }
}</span>

// Check는 시스템 상태를 확인하고 JSON 응답을 반환합니다
func (h *HealthHandler) Check(c *fiber.Ctx) error <span class="cov10" title="3">{
        response := HealthResponse{
                Status:    "ok",
                Timestamp: time.Now().UTC(),
                Version:   h.version,
        }

        return c.JSON(response)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package handler는 HTTP 요청 핸들러를 제공합니다
package handler

import (
        "strconv"
        "strings"

        "github.com/gofiber/fiber/v2"

        "oracle-etl/internal/domain"
        "oracle-etl/internal/usecase"
)

// JobHandler는 Job 관련 HTTP 핸들러입니다
type JobHandler struct {
        jobSvc *usecase.JobService
}

// NewJobHandler는 새로운 JobHandler를 생성합니다
func NewJobHandler(jobSvc *usecase.JobService) *JobHandler <span class="cov10" title="4">{
        return &amp;JobHandler{
                jobSvc: jobSvc,
        }
}</span>

// List는 Job 목록을 조회합니다
// GET /api/jobs
func (h *JobHandler) List(c *fiber.Ctx) error <span class="cov10" title="4">{
        filter := domain.DefaultJobListFilter()

        // Query 파라미터 파싱 - fasthttp 버퍼 재사용 문제 방지를 위해 문자열 복사
        if transportID := c.Query("transport_id"); transportID != "" </span><span class="cov5" title="2">{
                filter.TransportID = strings.Clone(transportID)
        }</span>
        <span class="cov10" title="4">if status := c.Query("status"); status != "" </span><span class="cov1" title="1">{
                filter.Status = domain.JobStatus(strings.Clone(status))
        }</span>
        <span class="cov10" title="4">if offset, err := strconv.Atoi(c.Query("offset", "0")); err == nil </span><span class="cov10" title="4">{
                filter.Offset = offset
        }</span>
        <span class="cov10" title="4">if limit, err := strconv.Atoi(c.Query("limit", "20")); err == nil </span><span class="cov10" title="4">{
                filter.Limit = limit
        }</span>

        <span class="cov10" title="4">resp, err := h.jobSvc.List(c.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "code":    "INTERNAL_ERROR",
                        "message": err.Error(),
                })
        }</span>

        <span class="cov10" title="4">return c.JSON(resp)</span>
}

// GetByID는 ID로 Job을 조회합니다
// GET /api/jobs/:id
func (h *JobHandler) GetByID(c *fiber.Ctx) error <span class="cov5" title="2">{
        // fasthttp 버퍼 재사용 문제 방지를 위해 문자열 복사
        id := strings.Clone(c.Params("id"))

        job, err := h.jobSvc.GetByID(c.Context(), id)
        if err != nil </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                        "code":    "JOB_NOT_FOUND",
                        "message": err.Error(),
                })
        }</span>

        <span class="cov1" title="1">return c.JSON(job)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package handler는 HTTP 요청 핸들러를 제공합니다
package handler

import (
        "github.com/gofiber/fiber/v2"
        "oracle-etl/internal/adapter/oracle"
)

// OracleHandler는 Oracle 관련 엔드포인트 핸들러입니다
type OracleHandler struct {
        repo oracle.Repository
}

// NewOracleHandler는 새로운 OracleHandler를 생성합니다
func NewOracleHandler(repo oracle.Repository) *OracleHandler <span class="cov10" title="2">{
        return &amp;OracleHandler{
                repo: repo,
        }
}</span>

// GetStatus는 Oracle 연결 상태를 반환합니다 (GET /api/oracle/status)
// 응답 예시:
//
//        {
//          "connected": true,
//          "database_version": "19.0.0.0.0",
//          "instance_name": "ATP_HIGH",
//          "pool_stats": {
//            "active_connections": 2,
//            "idle_connections": 8,
//            "max_connections": 10
//          }
//        }
func (h *OracleHandler) GetStatus(c *fiber.Ctx) error <span class="cov10" title="2">{
        ctx := c.Context()

        status, err := h.repo.GetStatus(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "code":    "ORACLE_STATUS_ERROR",
                        "message": "Oracle 상태 조회 실패",
                        "error":   err.Error(),
                })
        }</span>

        <span class="cov1" title="1">return c.JSON(status)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package handler는 HTTP 요청 핸들러를 제공합니다
package handler

import (
        "bufio"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/gofiber/fiber/v2"

        "oracle-etl/internal/adapter/sse"
)

// StatusHandler는 SSE 상태 스트리밍 핸들러입니다
type StatusHandler struct {
        broadcaster *sse.Broadcaster
}

// NewStatusHandler는 새로운 StatusHandler를 생성합니다
func NewStatusHandler(broadcaster *sse.Broadcaster) *StatusHandler <span class="cov10" title="4">{
        return &amp;StatusHandler{
                broadcaster: broadcaster,
        }
}</span>

// GetStatus는 Transport의 실시간 상태를 SSE로 스트리밍합니다
// GET /api/transports/:id/status
func (h *StatusHandler) GetStatus(c *fiber.Ctx) error <span class="cov8" title="3">{
        // fasthttp 버퍼 재사용 문제 방지를 위해 문자열 복사
        transportID := strings.Clone(c.Params("id"))

        // SSE 헤더 설정
        c.Set("Content-Type", "text/event-stream")
        c.Set("Cache-Control", "no-cache")
        c.Set("Connection", "keep-alive")
        c.Set("X-Accel-Buffering", "no") // nginx 프록시 버퍼링 비활성화

        // SSE 스트리밍 시작
        c.Context().SetBodyStreamWriter(func(w *bufio.Writer) </span><span class="cov8" title="3">{
                // 클라이언트 등록
                client := h.broadcaster.Register(transportID)
                defer h.broadcaster.Unregister(client.ID)

                // 초기 연결 확인 이벤트 전송
                initialEvent := sse.SSEEvent{
                        Event: "connected",
                        Data: map[string]string{
                                "transport_id": transportID,
                                "client_id":    client.ID,
                                "message":      "SSE 연결이 설정되었습니다",
                        },
                }
                h.writeSSEEvent(w, initialEvent)
                _ = w.Flush() // 초기 이벤트 전송 실패는 무시

                // 이벤트 스트리밍
                for </span><span class="cov10" title="4">{
                        select </span>{
                        case event, ok := &lt;-client.Events:<span class="cov1" title="1">
                                if !ok </span><span class="cov0" title="0">{
                                        // 채널이 닫힘
                                        return
                                }</span>
                                <span class="cov1" title="1">h.writeSSEEvent(w, event)
                                if err := w.Flush(); err != nil </span><span class="cov0" title="0">{
                                        // 클라이언트 연결이 끊어짐
                                        return
                                }</span>

                        case &lt;-client.Done:<span class="cov8" title="3">
                                // 클라이언트 종료 신호
                                return</span>
                        }
                }
        })

        <span class="cov8" title="3">return nil</span>
}

// writeSSEEvent는 SSE 형식으로 이벤트를 작성합니다
func (h *StatusHandler) writeSSEEvent(w *bufio.Writer, event sse.SSEEvent) <span class="cov10" title="4">{
        // event: {type}
        fmt.Fprintf(w, "event: %s\n", event.Event)

        // data: {json}
        data, err := json.Marshal(event.Data)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="4">fmt.Fprintf(w, "data: %s\n\n", string(data))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package handler는 HTTP 요청 핸들러를 제공합니다
package handler

import (
        "github.com/gofiber/fiber/v2"
        "oracle-etl/internal/adapter/oracle"
        "oracle-etl/internal/domain"
)

// TableHandler는 테이블 관련 엔드포인트 핸들러입니다
type TableHandler struct {
        repo         oracle.Repository
        defaultOwner string
}

// NewTableHandler는 새로운 TableHandler를 생성합니다
func NewTableHandler(repo oracle.Repository, defaultOwner string) *TableHandler <span class="cov10" title="7">{
        return &amp;TableHandler{
                repo:         repo,
                defaultOwner: defaultOwner,
        }
}</span>

// GetTables는 테이블 목록을 반환합니다 (GET /api/tables)
// 응답 예시:
//
//        {
//          "tables": [
//            {
//              "name": "VBRP",
//              "owner": "SAPSR3",
//              "row_count": 250000,
//              "column_count": 274
//            }
//          ],
//          "total": 40
//        }
func (h *TableHandler) GetTables(c *fiber.Ctx) error <span class="cov7" title="4">{
        ctx := c.Context()

        // 쿼리 파라미터에서 owner 추출 (없으면 기본값 사용)
        owner := c.Query("owner", h.defaultOwner)
        if owner == "" </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "code":    "VALIDATION_ERROR",
                        "message": "owner 파라미터가 필요합니다",
                })
        }</span>

        <span class="cov6" title="3">tables, err := h.repo.GetTables(ctx, owner)
        if err != nil </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "code":    "TABLE_LIST_ERROR",
                        "message": "테이블 목록 조회 실패",
                        "error":   err.Error(),
                })
        }</span>

        <span class="cov4" title="2">response := domain.TableListResponse{
                Tables: tables,
                Total:  len(tables),
        }

        return c.JSON(response)</span>
}

// GetSampleData는 테이블의 샘플 데이터를 반환합니다 (GET /api/tables/:name/sample)
// 응답 예시:
//
//        {
//          "table": "VBRP",
//          "columns": ["MANDT", "VBELN", "POSNR", ...],
//          "rows": [
//            {"MANDT": "800", "VBELN": "0090000001", ...},
//            ...
//          ],
//          "count": 100
//        }
func (h *TableHandler) GetSampleData(c *fiber.Ctx) error <span class="cov6" title="3">{
        ctx := c.Context()

        // 경로 파라미터에서 테이블 이름 추출
        tableName := c.Params("name")
        if tableName == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "code":    "VALIDATION_ERROR",
                        "message": "테이블 이름이 필요합니다",
                })
        }</span>

        // 쿼리 파라미터에서 owner와 limit 추출
        <span class="cov6" title="3">owner := c.Query("owner", h.defaultOwner)
        if owner == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "code":    "VALIDATION_ERROR",
                        "message": "owner 파라미터가 필요합니다",
                })
        }</span>

        <span class="cov6" title="3">limit := c.QueryInt("limit", 100)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov6" title="3">if limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 1000 // 최대 1000개로 제한
        }</span>

        <span class="cov6" title="3">sample, err := h.repo.GetSampleData(ctx, owner, tableName, limit)
        if err != nil </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "code":    "SAMPLE_DATA_ERROR",
                        "message": "샘플 데이터 조회 실패",
                        "error":   err.Error(),
                })
        }</span>

        <span class="cov4" title="2">return c.JSON(sample)</span>
}

// GetTableColumns는 테이블의 컬럼 정보를 반환합니다 (GET /api/tables/:name/columns)
func (h *TableHandler) GetTableColumns(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()

        // 경로 파라미터에서 테이블 이름 추출
        tableName := c.Params("name")
        if tableName == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "code":    "VALIDATION_ERROR",
                        "message": "테이블 이름이 필요합니다",
                })
        }</span>

        // 쿼리 파라미터에서 owner 추출
        <span class="cov0" title="0">owner := c.Query("owner", h.defaultOwner)
        if owner == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "code":    "VALIDATION_ERROR",
                        "message": "owner 파라미터가 필요합니다",
                })
        }</span>

        <span class="cov0" title="0">columns, err := h.repo.GetTableColumns(ctx, owner, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "code":    "COLUMN_INFO_ERROR",
                        "message": "컬럼 정보 조회 실패",
                        "error":   err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "table":   tableName,
                "columns": columns,
                "count":   len(columns),
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package handler는 HTTP 요청 핸들러를 제공합니다
package handler

import (
        "strconv"
        "strings"

        "github.com/gofiber/fiber/v2"

        "oracle-etl/internal/domain"
        "oracle-etl/internal/usecase"
)

// TransportHandler는 Transport 관련 HTTP 핸들러입니다
type TransportHandler struct {
        transportSvc *usecase.TransportService
        jobSvc       *usecase.JobService
}

// NewTransportHandler는 새로운 TransportHandler를 생성합니다
func NewTransportHandler(transportSvc *usecase.TransportService, jobSvc *usecase.JobService) *TransportHandler <span class="cov9" title="9">{
        return &amp;TransportHandler{
                transportSvc: transportSvc,
                jobSvc:       jobSvc,
        }
}</span>

// Create는 새로운 Transport를 생성합니다
// POST /api/transports
func (h *TransportHandler) Create(c *fiber.Ctx) error <span class="cov10" title="10">{
        var req domain.CreateTransportRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "code":    "INVALID_REQUEST",
                        "message": "요청 본문을 파싱할 수 없습니다: " + err.Error(),
                })
        }</span>

        <span class="cov10" title="10">transport, err := h.transportSvc.Create(c.Context(), req)
        if err != nil </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "code":    "VALIDATION_ERROR",
                        "message": err.Error(),
                })
        }</span>

        <span class="cov9" title="9">return c.Status(fiber.StatusCreated).JSON(transport)</span>
}

// List는 Transport 목록을 조회합니다
// GET /api/transports
func (h *TransportHandler) List(c *fiber.Ctx) error <span class="cov1" title="1">{
        offset, _ := strconv.Atoi(c.Query("offset", "0"))
        limit, _ := strconv.Atoi(c.Query("limit", "20"))

        resp, err := h.transportSvc.List(c.Context(), offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "code":    "INTERNAL_ERROR",
                        "message": err.Error(),
                })
        }</span>

        <span class="cov1" title="1">return c.JSON(resp)</span>
}

// GetByID는 ID로 Transport를 조회합니다
// GET /api/transports/:id
func (h *TransportHandler) GetByID(c *fiber.Ctx) error <span class="cov5" title="3">{
        // fasthttp 버퍼 재사용 문제 방지를 위해 문자열 복사
        id := strings.Clone(c.Params("id"))

        transport, err := h.transportSvc.GetByID(c.Context(), id)
        if err != nil </span><span class="cov3" title="2">{
                return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                        "code":    "TRANSPORT_NOT_FOUND",
                        "message": err.Error(),
                })
        }</span>

        <span class="cov1" title="1">return c.JSON(transport)</span>
}

// Delete는 Transport를 삭제합니다
// DELETE /api/transports/:id
func (h *TransportHandler) Delete(c *fiber.Ctx) error <span class="cov1" title="1">{
        // fasthttp 버퍼 재사용 문제 방지를 위해 문자열 복사
        id := strings.Clone(c.Params("id"))

        if err := h.transportSvc.Delete(c.Context(), id); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                        "code":    "TRANSPORT_NOT_FOUND",
                        "message": err.Error(),
                })
        }</span>

        <span class="cov1" title="1">return c.SendStatus(fiber.StatusNoContent)</span>
}

// Execute는 Transport를 실행하고 새 Job을 생성합니다
// POST /api/transports/:id/execute
func (h *TransportHandler) Execute(c *fiber.Ctx) error <span class="cov7" title="5">{
        // fasthttp 버퍼 재사용 문제 방지를 위해 문자열 복사
        transportID := strings.Clone(c.Params("id"))

        // Transport 존재 여부 및 실행 가능 여부 확인
        transport, err := h.transportSvc.GetByID(c.Context(), transportID)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                        "code":    "TRANSPORT_NOT_FOUND",
                        "message": err.Error(),
                })
        }</span>

        <span class="cov7" title="5">if !transport.CanExecute() </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusConflict).JSON(fiber.Map{
                        "code":    "TRANSPORT_NOT_EXECUTABLE",
                        "message": "Transport가 이미 실행 중이거나 비활성화 상태입니다",
                })
        }</span>

        // 새 Job 생성
        <span class="cov7" title="5">job, err := h.jobSvc.CreateJob(c.Context(), transportID)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "code":    "JOB_CREATION_FAILED",
                        "message": err.Error(),
                })
        }</span>

        // 응답 생성
        <span class="cov7" title="5">resp := domain.ExecuteJobResponse{
                JobID:       job.ID,
                TransportID: job.TransportID,
                Version:     job.Version,
                Status:      job.Status,
        }

        // Note: 실제 ETL 실행은 비동기로 처리됩니다
        // TODO: M5에서 goroutine으로 Oracle 추출 + GCS 업로드 실행

        return c.Status(fiber.StatusAccepted).JSON(resp)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package oracle은 Oracle 데이터베이스 연결 및 데이터 추출 기능을 제공합니다.
package oracle

import (
        "context"
        "fmt"
        "sync"

        "oracle-etl/internal/domain"
)

// Extractor는 Oracle에서 데이터를 추출하는 인터페이스입니다
type Extractor interface {
        // ExtractTable은 단일 테이블의 데이터를 추출합니다
        ExtractTable(ctx context.Context, owner, tableName string, opts domain.ExtractionOptions, handler func(chunk *domain.ChunkResult) error) error

        // ExtractTables는 여러 테이블의 데이터를 병렬로 추출합니다
        ExtractTables(ctx context.Context, owner string, tableNames []string, opts domain.ExtractionOptions, parallelism int, handler func(chunk *domain.ChunkResult) error) error
}

// DataExtractor는 Extractor 인터페이스의 구현체입니다
type DataExtractor struct {
        repo Repository
}

// NewDataExtractor는 새로운 DataExtractor를 생성합니다
func NewDataExtractor(repo Repository) *DataExtractor <span class="cov10" title="6">{
        return &amp;DataExtractor{
                repo: repo,
        }
}</span>

// ExtractTable은 단일 테이블의 데이터를 추출합니다
func (e *DataExtractor) ExtractTable(ctx context.Context, owner, tableName string, opts domain.ExtractionOptions, handler func(chunk *domain.ChunkResult) error) error <span class="cov7" title="4">{
        // 기본값 적용
        if opts.ChunkSize &lt;= 0 </span><span class="cov1" title="1">{
                opts.ChunkSize = 10000
        }</span>
        <span class="cov7" title="4">if opts.FetchArraySize &lt;= 0 </span><span class="cov1" title="1">{
                opts.FetchArraySize = 1000
        }</span>

        <span class="cov7" title="4">return e.repo.StreamTableData(ctx, owner, tableName, opts, handler)</span>
}

// ExtractTables는 여러 테이블의 데이터를 병렬로 추출합니다
func (e *DataExtractor) ExtractTables(ctx context.Context, owner string, tableNames []string, opts domain.ExtractionOptions, parallelism int, handler func(chunk *domain.ChunkResult) error) error <span class="cov4" title="2">{
        if parallelism &lt;= 0 </span><span class="cov0" title="0">{
                parallelism = 4
        }</span>

        // 세마포어 역할을 하는 채널
        <span class="cov4" title="2">sem := make(chan struct{}, parallelism)
        var wg sync.WaitGroup

        // 에러 수집
        errCh := make(chan error, len(tableNames))

        // mutex for handler (thread-safe handler call)
        var mu sync.Mutex

        for _, tableName := range tableNames </span><span class="cov9" title="5">{
                wg.Add(1)
                go func(table string) </span><span class="cov9" title="5">{
                        defer wg.Done()

                        // 세마포어 획득
                        sem &lt;- struct{}{}
                        defer func() </span><span class="cov9" title="5">{ &lt;-sem }</span>()

                        // 컨텍스트 취소 확인
                        <span class="cov9" title="5">select </span>{
                        case &lt;-ctx.Done():<span class="cov4" title="2">
                                errCh &lt;- ctx.Err()
                                return</span>
                        default:<span class="cov6" title="3"></span>
                        }

                        // 테이블 추출
                        <span class="cov6" title="3">err := e.repo.StreamTableData(ctx, owner, table, opts, func(chunk *domain.ChunkResult) error </span><span class="cov6" title="3">{
                                mu.Lock()
                                defer mu.Unlock()
                                return handler(chunk)
                        }</span>)
                        <span class="cov6" title="3">if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- fmt.Errorf("테이블 %s 추출 실패: %w", table, err)
                        }</span>
                }(tableName)
        }

        // 모든 goroutine 완료 대기
        <span class="cov4" title="2">wg.Wait()
        close(errCh)

        // 에러 수집 및 반환
        var errors []error
        for err := range errCh </span><span class="cov4" title="2">{
                errors = append(errors, err)
        }</span>

        <span class="cov4" title="2">if len(errors) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("%d개 테이블 추출 실패: %v", len(errors), errors[0])
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ExtractionProgress는 추출 진행 상황을 나타냅니다
type ExtractionProgress struct {
        TableName       string  `json:"table_name"`
        RowsProcessed   int64   `json:"rows_processed"`
        RowsPerSecond   float64 `json:"rows_per_second"`
        ProgressPercent float64 `json:"progress_percent"`
        IsComplete      bool    `json:"is_complete"`
}

// ExtractionResult는 테이블 추출 완료 결과를 나타냅니다
type ExtractionResult struct {
        TableName        string `json:"table_name"`
        TotalRows        int64  `json:"total_rows"`
        BytesTransferred int64  `json:"bytes_transferred"`
        DurationSeconds  float64 `json:"duration_seconds"`
        ChunksProcessed  int    `json:"chunks_processed"`
        Error            string `json:"error,omitempty"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package oracle은 Oracle 데이터베이스 연결 및 데이터 추출 기능을 제공합니다.
package oracle

import (
        "context"
        "errors"
        "time"

        "sync"

        "oracle-etl/internal/domain"
)

// MockRepository는 테스트용 Oracle 저장소 Mock입니다
type MockRepository struct {
        mu sync.Mutex // 동시성 보호용 뮤텍스

        // 테스트 설정 필드
        ShouldError       bool
        ErrorMessage      string
        MockStatus        *domain.OracleStatus
        MockTables        []domain.TableInfo
        MockColumns       []domain.ColumnInfo
        MockSampleData    *domain.SampleData
        MockChunks        []*domain.ChunkResult
        PingCalled        bool
        CloseCalled       bool
        GetStatusCalled   bool
        GetTablesCalled   bool
        GetSampleCalled   bool
        StreamCalled      bool

        // 테이블별 에러 설정 (부분 실패 테스트용)
        TableErrors map[string]error

        // 커스텀 StreamTableData 함수 (동시성 테스트용)
        StreamTableDataFunc func(ctx context.Context, owner, tableName string, opts domain.ExtractionOptions, handler func(chunk *domain.ChunkResult) error) error
}

// NewMockRepository는 새로운 MockRepository를 생성합니다
func NewMockRepository() *MockRepository <span class="cov10" title="13">{
        return &amp;MockRepository{
                MockStatus: &amp;domain.OracleStatus{
                        Connected:       true,
                        DatabaseVersion: "19.0.0.0.0",
                        InstanceName:    "ATP_HIGH",
                        PoolStats: domain.PoolStats{
                                ActiveConnections: 2,
                                IdleConnections:   8,
                                MaxConnections:    10,
                        },
                        CheckedAt: time.Now().UTC(),
                },
                MockTables: []domain.TableInfo{
                        {Name: "VBRP", Owner: "SAPSR3", RowCount: 250000, ColumnCount: 274},
                        {Name: "VBRK", Owner: "SAPSR3", RowCount: 100000, ColumnCount: 180},
                },
                MockColumns: []domain.ColumnInfo{
                        {Name: "MANDT", DataType: "VARCHAR2", Nullable: false, Position: 1},
                        {Name: "VBELN", DataType: "VARCHAR2", Nullable: false, Position: 2},
                        {Name: "POSNR", DataType: "NUMBER", Nullable: false, Position: 3},
                },
                MockSampleData: &amp;domain.SampleData{
                        TableName: "VBRP",
                        Columns:   []string{"MANDT", "VBELN", "POSNR"},
                        Rows: []map[string]interface{}{
                                {"MANDT": "800", "VBELN": "0090000001", "POSNR": float64(1)},
                                {"MANDT": "800", "VBELN": "0090000002", "POSNR": float64(2)},
                        },
                        Count: 2,
                },
                TableErrors: make(map[string]error),
        }
}</span>

// GetStatus는 Oracle 연결 상태 및 풀 통계를 반환합니다
func (m *MockRepository) GetStatus(ctx context.Context) (*domain.OracleStatus, error) <span class="cov3" title="2">{
        m.GetStatusCalled = true
        if m.ShouldError </span><span class="cov1" title="1">{
                return nil, errors.New(m.ErrorMessage)
        }</span>
        <span class="cov1" title="1">return m.MockStatus, nil</span>
}

// GetTables는 접근 가능한 테이블 목록과 row count를 반환합니다
func (m *MockRepository) GetTables(ctx context.Context, owner string) ([]domain.TableInfo, error) <span class="cov1" title="1">{
        m.GetTablesCalled = true
        if m.ShouldError </span><span class="cov0" title="0">{
                return nil, errors.New(m.ErrorMessage)
        }</span>
        <span class="cov1" title="1">return m.MockTables, nil</span>
}

// GetTableColumns는 테이블의 컬럼 정보를 반환합니다
func (m *MockRepository) GetTableColumns(ctx context.Context, owner, tableName string) ([]domain.ColumnInfo, error) <span class="cov0" title="0">{
        if m.ShouldError </span><span class="cov0" title="0">{
                return nil, errors.New(m.ErrorMessage)
        }</span>
        <span class="cov0" title="0">return m.MockColumns, nil</span>
}

// GetSampleData는 테이블의 샘플 데이터를 반환합니다
func (m *MockRepository) GetSampleData(ctx context.Context, owner, tableName string, limit int) (*domain.SampleData, error) <span class="cov1" title="1">{
        m.GetSampleCalled = true
        if m.ShouldError </span><span class="cov0" title="0">{
                return nil, errors.New(m.ErrorMessage)
        }</span>
        <span class="cov1" title="1">return m.MockSampleData, nil</span>
}

// StreamTableData는 테이블 데이터를 청크 단위로 스트리밍합니다
func (m *MockRepository) StreamTableData(ctx context.Context, owner, tableName string, opts domain.ExtractionOptions, chunkHandler func(chunk *domain.ChunkResult) error) error <span class="cov8" title="8">{
        m.mu.Lock()
        m.StreamCalled = true
        m.mu.Unlock()

        // 커스텀 함수가 있으면 사용
        if m.StreamTableDataFunc != nil </span><span class="cov0" title="0">{
                return m.StreamTableDataFunc(ctx, owner, tableName, opts, chunkHandler)
        }</span>

        // 테이블별 에러 확인
        <span class="cov8" title="8">if err, ok := m.TableErrors[tableName]; ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="8">if m.ShouldError </span><span class="cov1" title="1">{
                return errors.New(m.ErrorMessage)
        }</span>

        // Mock 청크 데이터 스트리밍
        <span class="cov7" title="7">for _, chunk := range m.MockChunks </span><span class="cov8" title="9">{
                // 테이블 이름 설정
                chunkCopy := *chunk
                if chunkCopy.TableName == "" </span><span class="cov4" title="3">{
                        chunkCopy.TableName = tableName
                }</span>
                <span class="cov8" title="9">if err := chunkHandler(&amp;chunkCopy); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov7" title="6">return nil</span>
}

// Ping은 Oracle 연결을 테스트합니다
func (m *MockRepository) Ping(ctx context.Context) error <span class="cov1" title="1">{
        m.PingCalled = true
        if m.ShouldError </span><span class="cov0" title="0">{
                return errors.New(m.ErrorMessage)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Close는 커넥션 풀을 종료합니다
func (m *MockRepository) Close() error <span class="cov1" title="1">{
        m.CloseCalled = true
        return nil
}</span>

// 인터페이스 구현 확인
var _ Repository = (*MockRepository)(nil)
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package oracle은 Oracle 데이터베이스 연결 및 데이터 추출 기능을 제공합니다.
package oracle

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "sync"
        "time"

        _ "github.com/godror/godror"
        "oracle-etl/internal/domain"
)

// PoolConfig는 Oracle 커넥션 풀 설정입니다
type PoolConfig struct {
        WalletPath     string        // mTLS wallet 디렉토리 경로
        TNSName        string        // TNS 이름 (예: "oracledb_high")
        Username       string        // Oracle 사용자 이름
        Password       string        // Oracle 비밀번호
        PoolMinConns   int           // 최소 커넥션 수 (기본값: 2)
        PoolMaxConns   int           // 최대 커넥션 수 (기본값: 10)
        FetchArraySize int           // 배치 페치 크기 (기본값: 1000)
        PrefetchCount  int           // 프리페치 카운트 (기본값: 1000)
        ConnectTimeout time.Duration // 연결 타임아웃 (기본값: 30초)
        DefaultOwner   string        // 기본 스키마 소유자
}

// DefaultPoolConfig는 기본 풀 설정을 반환합니다
func DefaultPoolConfig() PoolConfig <span class="cov1" title="1">{
        return PoolConfig{
                PoolMinConns:   2,
                PoolMaxConns:   10,
                FetchArraySize: 1000,
                PrefetchCount:  1000,
                ConnectTimeout: 30 * time.Second,
        }
}</span>

// Pool은 Oracle 커넥션 풀을 관리합니다
type Pool struct {
        db              *sql.DB
        config          PoolConfig
        mu              sync.RWMutex //nolint:unused // 향후 스레드 안전 작업에 사용 예정
        activeConns     int //nolint:unused // 커넥션 모니터링용
        lastCheckedAt   time.Time //nolint:unused // 마지막 체크 시간 기록용
        databaseVersion string //nolint:unused // 캐싱된 버전 정보
        instanceName    string //nolint:unused // 캐싱된 인스턴스 이름
}

// NewPool은 새로운 Oracle 커넥션 풀을 생성합니다
func NewPool(cfg PoolConfig) (*Pool, error) <span class="cov0" title="0">{
        // 설정 기본값 적용
        if cfg.PoolMinConns &lt;= 0 </span><span class="cov0" title="0">{
                cfg.PoolMinConns = 2
        }</span>
        <span class="cov0" title="0">if cfg.PoolMaxConns &lt;= 0 </span><span class="cov0" title="0">{
                cfg.PoolMaxConns = 10
        }</span>
        <span class="cov0" title="0">if cfg.FetchArraySize &lt;= 0 </span><span class="cov0" title="0">{
                cfg.FetchArraySize = 1000
        }</span>
        <span class="cov0" title="0">if cfg.ConnectTimeout &lt;= 0 </span><span class="cov0" title="0">{
                cfg.ConnectTimeout = 30 * time.Second
        }</span>

        // 연결 문자열 구성
        <span class="cov0" title="0">var connStr string
        if cfg.WalletPath != "" </span><span class="cov0" title="0">{
                // mTLS wallet 사용 시
                connStr = fmt.Sprintf(`user="%s" password="%s" connectString="%s" 
                        poolMinSessions=%d poolMaxSessions=%d 
                        configDir="%s"`,
                        cfg.Username, cfg.Password, cfg.TNSName,
                        cfg.PoolMinConns, cfg.PoolMaxConns,
                        cfg.WalletPath)
        }</span> else<span class="cov0" title="0"> {
                // 일반 연결
                connStr = fmt.Sprintf(`user="%s" password="%s" connectString="%s" 
                        poolMinSessions=%d poolMaxSessions=%d`,
                        cfg.Username, cfg.Password, cfg.TNSName,
                        cfg.PoolMinConns, cfg.PoolMaxConns)
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("godror", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Oracle 연결 실패: %w", err)
        }</span>

        // 연결 풀 설정
        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.PoolMaxConns)
        db.SetMaxIdleConns(cfg.PoolMinConns)
        db.SetConnMaxLifetime(30 * time.Minute)

        pool := &amp;Pool{
                db:     db,
                config: cfg,
        }

        return pool, nil</span>
}

// DB는 내부 sql.DB 인스턴스를 반환합니다 (테스트용)
func (p *Pool) DB() *sql.DB <span class="cov0" title="0">{
        return p.db
}</span>

// Ping은 Oracle 연결을 테스트합니다
func (p *Pool) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return p.db.PingContext(ctx)
}</span>

// Close는 커넥션 풀을 종료합니다
func (p *Pool) Close() error <span class="cov0" title="0">{
        return p.db.Close()
}</span>

// GetStatus는 Oracle 연결 상태 및 풀 통계를 반환합니다
func (p *Pool) GetStatus(ctx context.Context) (*domain.OracleStatus, error) <span class="cov0" title="0">{
        status := &amp;domain.OracleStatus{
                CheckedAt: time.Now().UTC(),
        }

        // 연결 테스트
        if err := p.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                status.Connected = false
                status.Error = err.Error()
                return status, nil
        }</span>

        <span class="cov0" title="0">status.Connected = true

        // 데이터베이스 버전 조회
        var version string
        err := p.db.QueryRowContext(ctx, "SELECT banner FROM v$version WHERE ROWNUM = 1").Scan(&amp;version)
        if err != nil </span><span class="cov0" title="0">{
                // 버전 조회 실패해도 연결은 성공한 것으로 처리
                version = "Unknown"
        }</span>
        <span class="cov0" title="0">status.DatabaseVersion = extractVersion(version)

        // 인스턴스 이름 조회
        var instanceName string
        err = p.db.QueryRowContext(ctx, "SELECT instance_name FROM v$instance").Scan(&amp;instanceName)
        if err != nil </span><span class="cov0" title="0">{
                instanceName = "Unknown"
        }</span>
        <span class="cov0" title="0">status.InstanceName = instanceName

        // 풀 통계 조회
        stats := p.db.Stats()
        status.PoolStats = domain.PoolStats{
                ActiveConnections: stats.InUse,
                IdleConnections:   stats.Idle,
                MaxConnections:    p.config.PoolMaxConns,
        }

        return status, nil</span>
}

// GetTables는 접근 가능한 테이블 목록과 row count를 반환합니다
func (p *Pool) GetTables(ctx context.Context, owner string) ([]domain.TableInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        t.table_name,
                        t.owner,
                        NVL(t.num_rows, 0) as row_count,
                        (SELECT COUNT(*) FROM all_tab_columns c WHERE c.owner = t.owner AND c.table_name = t.table_name) as column_count
                FROM all_tables t
                WHERE t.owner = :1
                ORDER BY t.table_name
        `

        rows, err := p.db.QueryContext(ctx, query, owner)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("테이블 목록 조회 실패: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []domain.TableInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var t domain.TableInfo
                if err := rows.Scan(&amp;t.Name, &amp;t.Owner, &amp;t.RowCount, &amp;t.ColumnCount); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("테이블 정보 스캔 실패: %w", err)
                }</span>
                <span class="cov0" title="0">tables = append(tables, t)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("테이블 목록 순회 실패: %w", err)
        }</span>

        <span class="cov0" title="0">return tables, nil</span>
}

// GetTableColumns는 테이블의 컬럼 정보를 반환합니다
func (p *Pool) GetTableColumns(ctx context.Context, owner, tableName string) ([]domain.ColumnInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        column_name,
                        data_type,
                        CASE WHEN nullable = 'Y' THEN 1 ELSE 0 END as nullable,
                        column_id
                FROM all_tab_columns
                WHERE owner = :1 AND table_name = :2
                ORDER BY column_id
        `

        rows, err := p.db.QueryContext(ctx, query, owner, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("컬럼 목록 조회 실패: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var columns []domain.ColumnInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var c domain.ColumnInfo
                var nullable int
                if err := rows.Scan(&amp;c.Name, &amp;c.DataType, &amp;nullable, &amp;c.Position); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("컬럼 정보 스캔 실패: %w", err)
                }</span>
                <span class="cov0" title="0">c.Nullable = nullable == 1
                columns = append(columns, c)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("컬럼 목록 순회 실패: %w", err)
        }</span>

        <span class="cov0" title="0">return columns, nil</span>
}

// GetSampleData는 테이블의 샘플 데이터를 반환합니다
func (p *Pool) GetSampleData(ctx context.Context, owner, tableName string, limit int) (*domain.SampleData, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        // 컬럼 정보 조회
        <span class="cov0" title="0">columns, err := p.GetTableColumns(ctx, owner, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">columnNames := make([]string, len(columns))
        for i, c := range columns </span><span class="cov0" title="0">{
                columnNames[i] = c.Name
        }</span>

        // 샘플 데이터 조회
        // #nosec G201 -- owner와 tableName은 API 레벨에서 검증된 입력값입니다
        <span class="cov0" title="0">query := fmt.Sprintf("SELECT * FROM %s.%s WHERE ROWNUM &lt;= :1", owner, tableName)
        rows, err := p.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("샘플 데이터 조회 실패: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // 결과 스캔
        data := &amp;domain.SampleData{
                TableName: tableName,
                Columns:   columnNames,
                Rows:      []map[string]interface{}{},
        }

        colTypes, err := rows.ColumnTypes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("컬럼 타입 조회 실패: %w", err)
        }</span>

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                // 동적 스캔을 위한 슬라이스 생성
                values := make([]interface{}, len(colTypes))
                valuePtrs := make([]interface{}, len(colTypes))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("데이터 스캔 실패: %w", err)
                }</span>

                <span class="cov0" title="0">row := make(map[string]interface{})
                for i, col := range columnNames </span><span class="cov0" title="0">{
                        row[col] = convertValue(values[i])
                }</span>
                <span class="cov0" title="0">data.Rows = append(data.Rows, row)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("데이터 순회 실패: %w", err)
        }</span>

        <span class="cov0" title="0">data.Count = len(data.Rows)
        return data, nil</span>
}

// StreamTableData는 테이블 데이터를 청크 단위로 스트리밍합니다
func (p *Pool) StreamTableData(ctx context.Context, owner, tableName string, opts domain.ExtractionOptions, chunkHandler func(chunk *domain.ChunkResult) error) error <span class="cov0" title="0">{
        if opts.ChunkSize &lt;= 0 </span><span class="cov0" title="0">{
                opts.ChunkSize = 10000
        }</span>
        <span class="cov0" title="0">if opts.FetchArraySize &lt;= 0 </span><span class="cov0" title="0">{
                opts.FetchArraySize = p.config.FetchArraySize
        }</span>

        // 전체 데이터 조회 쿼리
        // #nosec G201 -- owner와 tableName은 API 레벨에서 검증된 입력값입니다
        <span class="cov0" title="0">query := fmt.Sprintf("SELECT * FROM %s.%s", owner, tableName)
        rows, err := p.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("데이터 스트리밍 시작 실패: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // 컬럼 정보 조회
        colTypes, err := rows.ColumnTypes()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("컬럼 타입 조회 실패: %w", err)
        }</span>

        <span class="cov0" title="0">columnNames := make([]string, len(colTypes))
        for i, ct := range colTypes </span><span class="cov0" title="0">{
                columnNames[i] = ct.Name()
        }</span>

        <span class="cov0" title="0">chunkNumber := 0
        var totalRowsSent int64
        chunkRows := make([]map[string]interface{}, 0, opts.ChunkSize)

        for rows.Next() </span><span class="cov0" title="0">{
                // 동적 스캔
                values := make([]interface{}, len(colTypes))
                valuePtrs := make([]interface{}, len(colTypes))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("데이터 스캔 실패: %w", err)
                }</span>

                <span class="cov0" title="0">row := make(map[string]interface{})
                for i, col := range columnNames </span><span class="cov0" title="0">{
                        row[col] = convertValue(values[i])
                }</span>
                <span class="cov0" title="0">chunkRows = append(chunkRows, row)

                // 청크가 가득 찼으면 핸들러 호출
                if len(chunkRows) &gt;= opts.ChunkSize </span><span class="cov0" title="0">{
                        chunkNumber++
                        totalRowsSent += int64(len(chunkRows))
                        chunk := &amp;domain.ChunkResult{
                                TableName:     tableName,
                                ChunkNumber:   chunkNumber,
                                Rows:          chunkRows,
                                RowCount:      len(chunkRows),
                                IsLastChunk:   false,
                                TotalRowsSent: totalRowsSent,
                        }
                        if err := chunkHandler(chunk); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("청크 핸들러 오류: %w", err)
                        }</span>
                        <span class="cov0" title="0">chunkRows = make([]map[string]interface{}, 0, opts.ChunkSize)</span>
                }
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("데이터 순회 실패: %w", err)
        }</span>

        // 마지막 청크 처리
        <span class="cov0" title="0">if len(chunkRows) &gt; 0 </span><span class="cov0" title="0">{
                chunkNumber++
                totalRowsSent += int64(len(chunkRows))
                chunk := &amp;domain.ChunkResult{
                        TableName:     tableName,
                        ChunkNumber:   chunkNumber,
                        Rows:          chunkRows,
                        RowCount:      len(chunkRows),
                        IsLastChunk:   true,
                        TotalRowsSent: totalRowsSent,
                }
                if err := chunkHandler(chunk); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("마지막 청크 핸들러 오류: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// extractVersion은 Oracle 버전 문자열에서 버전 번호를 추출합니다
func extractVersion(banner string) string <span class="cov4" title="3">{
        // 예: "Oracle Database 19c Enterprise Edition Release 19.0.0.0.0"
        parts := strings.Fields(banner)
        for _, part := range parts </span><span class="cov10" title="16">{
                if strings.Contains(part, ".") &amp;&amp; strings.Count(part, ".") &gt;= 2 </span><span class="cov3" title="2">{
                        return part
                }</span>
        }
        <span class="cov1" title="1">return banner</span>
}

// convertValue는 Oracle 값을 JSON 직렬화 가능한 형태로 변환합니다
func convertValue(v interface{}) interface{} <span class="cov6" title="5">{
        if v == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="4">switch val := v.(type) </span>{
        case []byte:<span class="cov1" title="1">
                return string(val)</span>
        case time.Time:<span class="cov1" title="1">
                return val.Format(time.RFC3339)</span>
        default:<span class="cov3" title="2">
                return val</span>
        }
}

// 인터페이스 구현 확인
var _ Repository = (*Pool)(nil)
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package sse는 Server-Sent Events 기능을 제공합니다
package sse

import (
        "context"
        "sync"
        "sync/atomic"

        "github.com/google/uuid"
)

// Client는 SSE 연결을 나타냅니다
type Client struct {
        ID          string        // 고유 클라이언트 ID
        TransportID string        // 필터링을 위한 Transport ID
        Events      chan SSEEvent // 이벤트 수신 채널
        Done        chan struct{} // 종료 신호 채널
}

// registrationMessage는 등록 메시지입니다
type registrationMessage struct {
        client *Client
        done   chan struct{} // 등록 완료 신호
}

// Broadcaster는 SSE 연결을 관리합니다
type Broadcaster struct {
        clients     sync.Map                   // map[clientID]*Client (스레드 안전)
        register    chan registrationMessage   // 클라이언트 등록 채널
        unregister  chan string                // 클라이언트 해제 채널
        clientCount int32                      // 총 클라이언트 수 (atomic)
        mu          sync.RWMutex //nolint:unused // 동기화용 뮤텍스
}

// NewBroadcaster는 새로운 Broadcaster를 생성합니다
func NewBroadcaster() *Broadcaster <span class="cov4" title="12">{
        return &amp;Broadcaster{
                register:   make(chan registrationMessage, 100),
                unregister: make(chan string, 100),
        }
}</span>

// Run은 Broadcaster를 실행합니다
// 컨텍스트가 취소될 때까지 실행됩니다
func (b *Broadcaster) Run(ctx context.Context) <span class="cov3" title="11">{
        for </span><span class="cov7" title="130">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov3" title="11">
                        // 모든 클라이언트에게 종료 신호 전송
                        b.clients.Range(func(key, value interface{}) bool </span><span class="cov3" title="9">{
                                if client, ok := value.(*Client); ok </span><span class="cov3" title="9">{
                                        select </span>{
                                        case &lt;-client.Done:<span class="cov0" title="0"></span>
                                                // 이미 닫힘
                                        default:<span class="cov3" title="9">
                                                close(client.Done)</span>
                                        }
                                }
                                <span class="cov3" title="9">return true</span>
                        })
                        <span class="cov3" title="11">return</span>

                case msg := &lt;-b.register:<span class="cov6" title="64">
                        b.clients.Store(msg.client.ID, msg.client)
                        atomic.AddInt32(&amp;b.clientCount, 1)
                        // 등록 완료 신호
                        close(msg.done)</span>

                case clientID := &lt;-b.unregister:<span class="cov5" title="55">
                        if value, ok := b.clients.LoadAndDelete(clientID); ok </span><span class="cov5" title="55">{
                                atomic.AddInt32(&amp;b.clientCount, -1)
                                if client, ok := value.(*Client); ok </span><span class="cov5" title="55">{
                                        // Done 채널을 먼저 닫아 클라이언트에게 종료 신호
                                        select </span>{
                                        case &lt;-client.Done:<span class="cov0" title="0"></span>
                                                // 이미 닫힘
                                        default:<span class="cov5" title="55">
                                                close(client.Done)</span>
                                        }
                                }
                        }
                }
        }
}

// Register는 새 클라이언트를 등록합니다
func (b *Broadcaster) Register(transportID string) *Client <span class="cov6" title="64">{
        client := &amp;Client{
                ID:          uuid.New().String(),
                TransportID: transportID,
                Events:      make(chan SSEEvent, 100), // 버퍼링된 채널
                Done:        make(chan struct{}),
        }

        done := make(chan struct{})
        b.register &lt;- registrationMessage{client: client, done: done}
        
        // 등록 완료 대기
        &lt;-done

        return client
}</span>

// Unregister는 클라이언트를 해제합니다
func (b *Broadcaster) Unregister(clientID string) <span class="cov6" title="64">{
        b.unregister &lt;- clientID
}</span>

// Broadcast는 특정 Transport의 모든 클라이언트에게 이벤트를 전송합니다
func (b *Broadcaster) Broadcast(transportID string, event SSEEvent) <span class="cov5" title="55">{
        b.clients.Range(func(key, value interface{}) bool </span><span class="cov10" title="1407">{
                client, ok := value.(*Client)
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>

                // TransportID가 일치하는 클라이언트에게만 전송
                <span class="cov10" title="1407">if client.TransportID == transportID </span><span class="cov9" title="1406">{
                        // Done 채널 확인하여 종료된 클라이언트에게 전송 방지
                        select </span>{
                        case &lt;-client.Done:<span class="cov0" title="0">
                                // 클라이언트가 종료됨
                                return true</span>
                        default:<span class="cov9" title="1406"></span>
                        }

                        // 논블로킹 전송 (채널이 가득 찬 경우 이벤트 드롭)
                        <span class="cov9" title="1406">select </span>{
                        case client.Events &lt;- event:<span class="cov9" title="1406"></span>
                        case &lt;-client.Done:<span class="cov0" title="0"></span>
                                // 클라이언트가 종료됨
                        default:<span class="cov0" title="0"></span>
                                // 채널이 가득 찬 경우 이벤트 스킵
                        }
                }
                <span class="cov10" title="1407">return true</span>
        })
}

// BroadcastProgress는 Progress 이벤트를 브로드캐스트합니다
func (b *Broadcaster) BroadcastProgress(event ProgressEvent) <span class="cov5" title="51">{
        b.Broadcast(event.TransportID, SSEEvent{
                Event: EventTypeProgress,
                Data:  event,
        })
}</span>

// BroadcastStatus는 Status 이벤트를 브로드캐스트합니다
func (b *Broadcaster) BroadcastStatus(event StatusEvent) <span class="cov1" title="1">{
        b.Broadcast(event.TransportID, SSEEvent{
                Event: EventTypeStatus,
                Data:  event,
        })
}</span>

// BroadcastError는 Error 이벤트를 브로드캐스트합니다
func (b *Broadcaster) BroadcastError(event ErrorEvent) <span class="cov1" title="1">{
        b.Broadcast(event.TransportID, SSEEvent{
                Event: EventTypeError,
                Data:  event,
        })
}</span>

// BroadcastComplete는 Complete 이벤트를 브로드캐스트합니다
func (b *Broadcaster) BroadcastComplete(event CompleteEvent) <span class="cov1" title="1">{
        b.Broadcast(event.TransportID, SSEEvent{
                Event: EventTypeComplete,
                Data:  event,
        })
}</span>

// ClientCount는 현재 연결된 클라이언트 수를 반환합니다
func (b *Broadcaster) ClientCount() int <span class="cov2" title="5">{
        return int(atomic.LoadInt32(&amp;b.clientCount))
}</span>

// ClientCountForTransport는 특정 Transport에 연결된 클라이언트 수를 반환합니다
func (b *Broadcaster) ClientCountForTransport(transportID string) int <span class="cov2" title="3">{
        count := 0
        b.clients.Range(func(key, value interface{}) bool </span><span class="cov3" title="9">{
                if client, ok := value.(*Client); ok </span><span class="cov3" title="9">{
                        if client.TransportID == transportID </span><span class="cov2" title="3">{
                                count++
                        }</span>
                }
                <span class="cov3" title="9">return true</span>
        })
        <span class="cov2" title="3">return count</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package sse는 Server-Sent Events 기능을 제공합니다
package sse

import (
        "encoding/json"
        "fmt"
        "time"
)

// 이벤트 타입 상수
const (
        // EventTypeProgress는 진행률 이벤트 타입입니다
        EventTypeProgress = "progress"
        // EventTypeStatus는 상태 변경 이벤트 타입입니다
        EventTypeStatus = "status"
        // EventTypeError는 에러 이벤트 타입입니다
        EventTypeError = "error"
        // EventTypeComplete는 완료 이벤트 타입입니다
        EventTypeComplete = "complete"
)

// 상태 상수
const (
        // StatusRunning은 실행 중 상태입니다
        StatusRunning = "running"
        // StatusCompleted는 완료 상태입니다
        StatusCompleted = "completed"
        // StatusFailed는 실패 상태입니다
        StatusFailed = "failed"
)

// SSEEvent는 SSE 이벤트의 기본 구조입니다
type SSEEvent struct {
        Event string      `json:"-"`    // event type: progress, status, error, complete
        Data  interface{} `json:"data"` // 이벤트 데이터
}

// Format은 SSE 이벤트를 SSE 형식 문자열로 변환합니다
// 형식: event: {type}\ndata: {json}\n\n
func (e *SSEEvent) Format() (string, error) <span class="cov1" title="1">{
        data, err := json.Marshal(e.Data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("이벤트 데이터 직렬화 실패: %w", err)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("event: %s\ndata: %s\n\n", e.Event, string(data)), nil</span>
}

// ProgressEvent는 진행률 이벤트입니다
type ProgressEvent struct {
        TransportID     string  `json:"transport_id"`     // Transport ID
        JobID           string  `json:"job_id"`           // Job ID
        Table           string  `json:"table"`            // 현재 처리 중인 테이블
        RowsProcessed   int64   `json:"rows_processed"`   // 처리된 row 수
        RowsTotal       int64   `json:"rows_total"`       // 총 row 수 (-1 if unknown)
        RowsPerSecond   float64 `json:"rows_per_second"`  // 초당 처리 row 수
        BytesWritten    int64   `json:"bytes_written"`    // 작성된 바이트 수
        ProgressPercent float64 `json:"progress_percent"` // 진행률 (0-100)
}

// CalculateProgressPercent는 진행률을 계산합니다
func (e *ProgressEvent) CalculateProgressPercent() <span class="cov10" title="7">{
        if e.RowsTotal &lt;= 0 </span><span class="cov4" title="2">{
                e.ProgressPercent = 0.0
                return
        }</span>
        <span class="cov8" title="5">e.ProgressPercent = float64(e.RowsProcessed) / float64(e.RowsTotal) * 100.0</span>
}

// NewProgressEvent는 새로운 ProgressEvent를 생성합니다
func NewProgressEvent(transportID, jobID, table string, rowsProcessed, rowsTotal, bytesWritten int64) *ProgressEvent <span class="cov1" title="1">{
        event := &amp;ProgressEvent{
                TransportID:   transportID,
                JobID:         jobID,
                Table:         table,
                RowsProcessed: rowsProcessed,
                RowsTotal:     rowsTotal,
                BytesWritten:  bytesWritten,
        }
        event.CalculateProgressPercent()
        return event
}</span>

// StatusEvent는 상태 변경 이벤트입니다
type StatusEvent struct {
        TransportID string `json:"transport_id"` // Transport ID
        JobID       string `json:"job_id"`       // Job ID
        Status      string `json:"status"`       // 상태: running, completed, failed
        Message     string `json:"message"`      // 상태 메시지
}

// NewStatusEvent는 새로운 StatusEvent를 생성합니다
func NewStatusEvent(transportID, jobID, status, message string) *StatusEvent <span class="cov1" title="1">{
        return &amp;StatusEvent{
                TransportID: transportID,
                JobID:       jobID,
                Status:      status,
                Message:     message,
        }
}</span>

// ErrorEvent는 에러 이벤트입니다
type ErrorEvent struct {
        TransportID string `json:"transport_id"` // Transport ID
        JobID       string `json:"job_id"`       // Job ID
        Table       string `json:"table"`        // 에러 발생 테이블
        Code        string `json:"code"`         // 에러 코드
        Message     string `json:"message"`      // 에러 메시지
        Timestamp   string `json:"timestamp"`    // 에러 발생 시간 (ISO8601)
}

// NewErrorEvent는 새로운 ErrorEvent를 생성합니다
func NewErrorEvent(transportID, jobID, table, code, message string) *ErrorEvent <span class="cov1" title="1">{
        return &amp;ErrorEvent{
                TransportID: transportID,
                JobID:       jobID,
                Table:       table,
                Code:        code,
                Message:     message,
                Timestamp:   time.Now().UTC().Format(time.RFC3339),
        }
}</span>

// CompleteEvent는 완료 이벤트입니다
type CompleteEvent struct {
        TransportID   string  `json:"transport_id"`   // Transport ID
        JobID         string  `json:"job_id"`         // Job ID
        TotalRows     int64   `json:"total_rows"`     // 총 처리 row 수
        TotalBytes    int64   `json:"total_bytes"`    // 총 바이트 수
        DurationMs    int64   `json:"duration_ms"`    // 실행 시간 (밀리초)
        TablesCount   int     `json:"tables_count"`   // 처리된 테이블 수
        RowsPerSecond float64 `json:"rows_per_second"` // 평균 초당 처리 row 수
}

// NewCompleteEvent는 새로운 CompleteEvent를 생성합니다
func NewCompleteEvent(transportID, jobID string, totalRows, totalBytes, durationMs int64, tablesCount int) *CompleteEvent <span class="cov1" title="1">{
        var rowsPerSecond float64
        if durationMs &gt; 0 </span><span class="cov1" title="1">{
                // ms를 초로 변환하여 계산
                rowsPerSecond = float64(totalRows) / (float64(durationMs) / 1000.0)
        }</span>
        <span class="cov1" title="1">return &amp;CompleteEvent{
                TransportID:   transportID,
                JobID:         jobID,
                TotalRows:     totalRows,
                TotalBytes:    totalBytes,
                DurationMs:    durationMs,
                TablesCount:   tablesCount,
                RowsPerSecond: rowsPerSecond,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package sse는 Server-Sent Events 기능을 제공합니다
package sse

import (
        "sync"
        "time"
)

// TableMetrics는 테이블별 메트릭을 저장합니다
type TableMetrics struct {
        TotalRows     int64 // 총 row 수
        ProcessedRows int64 // 처리된 row 수
        BytesWritten  int64 // 작성된 바이트 수
}

// MetricsTracker는 ETL 작업의 메트릭을 추적합니다
type MetricsTracker struct {
        TransportID string // Transport ID
        JobID       string // Job ID
        TotalRows   int64  // 총 처리된 row 수
        TotalBytes  int64  // 총 바이트 수

        startTime time.Time              // 시작 시간
        tables    map[string]*TableMetrics // 테이블별 메트릭
        mu        sync.RWMutex           // 동기화를 위한 뮤텍스
}

// NewMetricsTracker는 새로운 MetricsTracker를 생성합니다
func NewMetricsTracker(transportID, jobID string) *MetricsTracker <span class="cov5" title="10">{
        return &amp;MetricsTracker{
                TransportID: transportID,
                JobID:       jobID,
                tables:      make(map[string]*TableMetrics),
        }
}</span>

// Start는 메트릭 추적을 시작합니다
func (m *MetricsTracker) Start() <span class="cov5" title="9">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.startTime = time.Now()
}</span>

// AddTable은 추적할 테이블을 추가합니다
func (m *MetricsTracker) AddTable(tableName string, totalRows int64) <span class="cov5" title="9">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.tables[tableName] = &amp;TableMetrics{
                TotalRows:     totalRows,
                ProcessedRows: 0,
                BytesWritten:  0,
        }
}</span>

// UpdateProgress는 테이블의 진행률을 업데이트합니다
func (m *MetricsTracker) UpdateProgress(tableName string, processedRows, bytesWritten int64) <span class="cov10" title="106">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if tableMetric, exists := m.tables[tableName]; exists </span><span class="cov10" title="106">{
                // 이전 값과의 차이를 계산하여 전체 합계 업데이트
                rowsDiff := processedRows - tableMetric.ProcessedRows
                bytesDiff := bytesWritten - tableMetric.BytesWritten

                tableMetric.ProcessedRows = processedRows
                tableMetric.BytesWritten = bytesWritten

                m.TotalRows += rowsDiff
                m.TotalBytes += bytesDiff
        }</span>
}

// GetProgressEvent는 특정 테이블의 ProgressEvent를 생성합니다
func (m *MetricsTracker) GetProgressEvent(tableName string) *ProgressEvent <span class="cov2" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        tableMetric, exists := m.tables[tableName]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov2" title="2">event := &amp;ProgressEvent{
                TransportID:   m.TransportID,
                JobID:         m.JobID,
                Table:         tableName,
                RowsProcessed: tableMetric.ProcessedRows,
                RowsTotal:     tableMetric.TotalRows,
                BytesWritten:  tableMetric.BytesWritten,
        }

        // 진행률 계산
        event.CalculateProgressPercent()

        // 초당 처리 row 수 계산
        elapsed := time.Since(m.startTime)
        if elapsed &gt; 0 </span><span class="cov2" title="2">{
                event.RowsPerSecond = float64(tableMetric.ProcessedRows) / elapsed.Seconds()
        }</span>

        <span class="cov2" title="2">return event</span>
}

// GetCompleteEvent는 완료 이벤트를 생성합니다
func (m *MetricsTracker) GetCompleteEvent() *CompleteEvent <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        elapsed := time.Since(m.startTime)
        durationMs := elapsed.Milliseconds()

        var rowsPerSecond float64
        if elapsed &gt; 0 </span><span class="cov1" title="1">{
                rowsPerSecond = float64(m.TotalRows) / elapsed.Seconds()
        }</span>

        <span class="cov1" title="1">return &amp;CompleteEvent{
                TransportID:   m.TransportID,
                JobID:         m.JobID,
                TotalRows:     m.TotalRows,
                TotalBytes:    m.TotalBytes,
                DurationMs:    durationMs,
                TablesCount:   len(m.tables),
                RowsPerSecond: rowsPerSecond,
        }</span>
}

// GetDuration은 현재까지의 실행 시간을 반환합니다
func (m *MetricsTracker) GetDuration() time.Duration <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        if m.startTime.IsZero() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return time.Since(m.startTime)</span>
}

// Reset은 모든 메트릭을 초기화합니다
func (m *MetricsTracker) Reset() <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.TotalRows = 0
        m.TotalBytes = 0
        m.startTime = time.Time{}
        m.tables = make(map[string]*TableMetrics)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package config는 애플리케이션 설정 관리를 담당합니다.
// Viper를 사용하여 config.yaml 파일과 환경 변수에서 설정을 로드합니다.
package config

import (
        "fmt"
        "strings"
        "time"

        "github.com/spf13/viper"
)

// Config는 애플리케이션 전체 설정 구조체입니다
type Config struct {
        Server    ServerConfig    `mapstructure:"server"`
        App       AppConfig       `mapstructure:"app"`
        Oracle    OracleConfig    `mapstructure:"oracle"`
        GCS       GCSConfig       `mapstructure:"gcs"`
        ETL       ETLConfig       `mapstructure:"etl"`
        Auth      AuthConfig      `mapstructure:"auth"`
        RateLimit RateLimitConfig `mapstructure:"rate_limit"`
        CORS      CORSConfig      `mapstructure:"cors"`
}

// ServerConfig는 HTTP 서버 관련 설정입니다
type ServerConfig struct {
        Port         int    `mapstructure:"port"`
        ReadTimeout  string `mapstructure:"read_timeout"`
        WriteTimeout string `mapstructure:"write_timeout"`
}

// AppConfig는 애플리케이션 메타데이터 설정입니다
type AppConfig struct {
        Name        string `mapstructure:"name"`
        Version     string `mapstructure:"version"`
        Environment string `mapstructure:"environment"`
}

// OracleConfig는 Oracle 데이터베이스 연결 설정입니다
type OracleConfig struct {
        WalletPath     string `mapstructure:"wallet_path"`      // mTLS wallet 디렉토리 경로
        TNSName        string `mapstructure:"tns_name"`         // TNS 이름 (예: "oracledb_high")
        Username       string `mapstructure:"username"`         // Oracle 사용자 이름
        Password       string `mapstructure:"password"`         // Oracle 비밀번호
        PoolMin        int    `mapstructure:"pool_min"`         // 최소 커넥션 수
        PoolMax        int    `mapstructure:"pool_max"`         // 최대 커넥션 수
        FetchArraySize int    `mapstructure:"fetch_array_size"` // 배치 페치 크기
        PrefetchCount  int    `mapstructure:"prefetch_count"`   // 프리페치 카운트
        DefaultOwner   string `mapstructure:"default_owner"`    // 기본 스키마 소유자
}

// GCSConfig는 Google Cloud Storage 연결 설정입니다
type GCSConfig struct {
        ProjectID       string `mapstructure:"project_id"`       // GCP 프로젝트 ID
        BucketName      string `mapstructure:"bucket_name"`      // 대상 버킷 이름
        CredentialsFile string `mapstructure:"credentials_file"` // 서비스 계정 JSON 파일 경로
        ChunkSize       int    `mapstructure:"chunk_size"`       // resumable 업로드 청크 크기 (바이트)
        TimeoutSeconds  int    `mapstructure:"timeout_seconds"`  // 작업 타임아웃 (초)
}

// ETLConfig는 ETL 작업 관련 설정입니다
type ETLConfig struct {
        ChunkSize      int    `mapstructure:"chunk_size"`      // 청크당 row 수
        ParallelTables int    `mapstructure:"parallel_tables"` // 병렬 처리 테이블 수
        RetryAttempts  int    `mapstructure:"retry_attempts"`  // 재시도 횟수
        RetryBackoff   string `mapstructure:"retry_backoff"`   // 재시도 간격
}

// AuthConfig는 API 인증 관련 설정입니다
type AuthConfig struct {
        Enabled      bool     `mapstructure:"enabled"`       // 인증 활성화 여부
        APIKeys      []string `mapstructure:"api_keys"`      // 유효한 API Key 목록
        BearerSecret string   `mapstructure:"bearer_secret"` // JWT 서명용 비밀키
}

// RateLimitConfig는 요청 제한 관련 설정입니다
type RateLimitConfig struct {
        Enabled           bool `mapstructure:"enabled"`             // Rate limiting 활성화 여부
        RequestsPerMinute int  `mapstructure:"requests_per_minute"` // 분당 최대 요청 수
        BurstSize         int  `mapstructure:"burst_size"`          // 버스트 허용 크기
}

// CORSConfig는 CORS 관련 설정입니다
type CORSConfig struct {
        Enabled          bool     `mapstructure:"enabled"`           // CORS 활성화 여부
        AllowOrigins     []string `mapstructure:"allow_origins"`     // 허용된 Origin 목록
        AllowMethods     []string `mapstructure:"allow_methods"`     // 허용된 HTTP 메서드 목록
        AllowHeaders     []string `mapstructure:"allow_headers"`     // 허용된 헤더 목록
        AllowCredentials bool     `mapstructure:"allow_credentials"` // 자격 증명 허용 여부
        ExposeHeaders    []string `mapstructure:"expose_headers"`    // 노출할 헤더 목록
        MaxAge           int      `mapstructure:"max_age"`           // preflight 캐시 시간 (초)
}

// Load는 지정된 경로의 설정 파일과 환경 변수에서 설정을 로드합니다
func Load(configPath string) (*Config, error) <span class="cov9" title="7">{
        v := viper.New()

        // 기본값 설정
        setDefaults(v)

        // 설정 파일 읽기
        v.SetConfigFile(configPath)
        v.SetConfigType("yaml")

        // 설정 파일 읽기 시도 - 파일이 없거나 읽기 실패해도 기본값 사용
        // 빈 파일이나 파일 없음은 정상적인 상황으로 처리
        _ = v.ReadInConfig()

        // 환경 변수 바인딩
        v.AutomaticEnv()
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        // 환경 변수 명시적 바인딩
        bindEnvVars(v)

        var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("설정 파싱 실패: %w", err)
        }</span>

        <span class="cov9" title="7">return &amp;cfg, nil</span>
}

// bindEnvVars는 환경 변수를 설정에 바인딩합니다
func bindEnvVars(v *viper.Viper) <span class="cov9" title="7">{
        // 서버 설정
        _ = v.BindEnv("server.port", "SERVER_PORT")

        // Oracle 설정
        _ = v.BindEnv("oracle.wallet_path", "ORACLE_WALLET_PATH")
        _ = v.BindEnv("oracle.tns_name", "ORACLE_TNS_NAME")
        _ = v.BindEnv("oracle.username", "ORACLE_USERNAME")
        _ = v.BindEnv("oracle.password", "ORACLE_PASSWORD")
        _ = v.BindEnv("oracle.pool_min", "ORACLE_POOL_MIN")
        _ = v.BindEnv("oracle.pool_max", "ORACLE_POOL_MAX")
        _ = v.BindEnv("oracle.fetch_array_size", "ORACLE_FETCH_ARRAY_SIZE")
        _ = v.BindEnv("oracle.default_owner", "ORACLE_DEFAULT_OWNER")

        // GCS 설정
        _ = v.BindEnv("gcs.project_id", "GCS_PROJECT_ID")
        _ = v.BindEnv("gcs.bucket_name", "GCS_BUCKET_NAME")
        _ = v.BindEnv("gcs.credentials_file", "GCS_CREDENTIALS_FILE")
        _ = v.BindEnv("gcs.chunk_size", "GCS_CHUNK_SIZE")
        _ = v.BindEnv("gcs.timeout_seconds", "GCS_TIMEOUT_SECONDS")

        // Auth 설정
        _ = v.BindEnv("auth.enabled", "AUTH_ENABLED")
        _ = v.BindEnv("auth.api_keys", "AUTH_API_KEYS")
        _ = v.BindEnv("auth.bearer_secret", "AUTH_BEARER_SECRET")

        // Rate Limit 설정
        _ = v.BindEnv("rate_limit.enabled", "RATE_LIMIT_ENABLED")
        _ = v.BindEnv("rate_limit.requests_per_minute", "RATE_LIMIT_REQUESTS_PER_MINUTE")
        _ = v.BindEnv("rate_limit.burst_size", "RATE_LIMIT_BURST_SIZE")

        // CORS 설정
        _ = v.BindEnv("cors.enabled", "CORS_ENABLED")
        _ = v.BindEnv("cors.allow_origins", "CORS_ALLOW_ORIGINS")
}</span>

// setDefaults는 Viper에 기본값을 설정합니다
func setDefaults(v *viper.Viper) <span class="cov9" title="7">{
        // 서버 기본값
        v.SetDefault("server.port", 8080)
        v.SetDefault("server.read_timeout", "10s")
        v.SetDefault("server.write_timeout", "300s") // ETL 작업을 위해 늘림

        // 앱 기본값
        v.SetDefault("app.name", "oracle-etl")
        v.SetDefault("app.version", "1.0.0")
        v.SetDefault("app.environment", "production")

        // Oracle 기본값
        v.SetDefault("oracle.pool_min", 2)
        v.SetDefault("oracle.pool_max", 10)
        v.SetDefault("oracle.fetch_array_size", 1000)
        v.SetDefault("oracle.prefetch_count", 1000)

        // GCS 기본값
        v.SetDefault("gcs.chunk_size", 16*1024*1024) // 16MB
        v.SetDefault("gcs.timeout_seconds", 600)     // 10분

        // ETL 기본값
        v.SetDefault("etl.chunk_size", 10000)
        v.SetDefault("etl.parallel_tables", 4)
        v.SetDefault("etl.retry_attempts", 3)
        v.SetDefault("etl.retry_backoff", "1s")

        // Auth 기본값
        v.SetDefault("auth.enabled", false)
        v.SetDefault("auth.api_keys", []string{})
        v.SetDefault("auth.bearer_secret", "")

        // Rate Limit 기본값
        v.SetDefault("rate_limit.enabled", false)
        v.SetDefault("rate_limit.requests_per_minute", 100)
        v.SetDefault("rate_limit.burst_size", 20)

        // CORS 기본값
        v.SetDefault("cors.enabled", false)
        v.SetDefault("cors.allow_origins", []string{"*"})
        v.SetDefault("cors.allow_methods", []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"})
        v.SetDefault("cors.allow_headers", []string{"Origin", "Content-Type", "Accept", "Authorization", "X-API-Key"})
        v.SetDefault("cors.allow_credentials", false)
        v.SetDefault("cors.expose_headers", []string{})
        v.SetDefault("cors.max_age", 86400) // 24시간
}</span>

// Validate는 설정의 유효성을 검사합니다
func (c *Config) Validate() error <span class="cov10" title="8">{
        // 포트 유효성 검사
        if c.Server.Port &lt; 0 || c.Server.Port &gt; 65535 </span><span class="cov4" title="2">{
                return fmt.Errorf("잘못된 포트 번호: %d (0-65535 범위여야 함)", c.Server.Port)
        }</span>

        // Oracle 설정 유효성 검사 (선택적 - 설정되지 않은 경우는 건너뜀)
        <span class="cov8" title="6">if c.Oracle.TNSName != "" </span><span class="cov4" title="2">{
                if c.Oracle.Username == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("Oracle 사용자 이름이 설정되지 않음")
                }</span>
                <span class="cov1" title="1">if c.Oracle.PoolMin &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Oracle 최소 풀 크기는 0 이상이어야 함")
                }</span>
                <span class="cov1" title="1">if c.Oracle.PoolMax &lt; c.Oracle.PoolMin </span><span class="cov0" title="0">{
                        return fmt.Errorf("Oracle 최대 풀 크기는 최소 풀 크기보다 크거나 같아야 함")
                }</span>
        }

        // GCS 설정 유효성 검사 (선택적)
        <span class="cov7" title="5">if c.GCS.BucketName != "" </span><span class="cov4" title="2">{
                if c.GCS.ProjectID == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("GCS 버킷이 설정되었지만 프로젝트 ID가 없음")
                }</span>
        }

        // Auth 설정 유효성 검사
        <span class="cov7" title="4">if c.Auth.Enabled </span><span class="cov0" title="0">{
                if len(c.Auth.APIKeys) == 0 &amp;&amp; c.Auth.BearerSecret == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("Auth가 활성화되었지만 API 키 또는 Bearer 비밀키가 설정되지 않음")
                }</span>
        }

        // Rate Limit 설정 유효성 검사
        <span class="cov7" title="4">if c.RateLimit.Enabled </span><span class="cov0" title="0">{
                if c.RateLimit.RequestsPerMinute &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Rate Limit가 활성화되었지만 requests_per_minute이 0 이하임")
                }</span>
        }

        <span class="cov7" title="4">return nil</span>
}

// HasOracleConfig는 Oracle 설정이 있는지 확인합니다
func (c *Config) HasOracleConfig() bool <span class="cov5" title="3">{
        return c.Oracle.TNSName != "" &amp;&amp; c.Oracle.Username != ""
}</span>

// HasGCSConfig는 GCS 설정이 있는지 확인합니다
func (c *Config) HasGCSConfig() bool <span class="cov7" title="4">{
        return c.GCS.ProjectID != "" &amp;&amp; c.GCS.BucketName != ""
}</span>

// GetGCSTimeout는 GCS 타임아웃을 time.Duration으로 반환합니다
func (c *Config) GetGCSTimeout() time.Duration <span class="cov7" title="4">{
        if c.GCS.TimeoutSeconds &lt;= 0 </span><span class="cov4" title="2">{
                return 10 * time.Minute // 기본값
        }</span>
        <span class="cov4" title="2">return time.Duration(c.GCS.TimeoutSeconds) * time.Second</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package domain은 ETL 파이프라인의 핵심 도메인 모델을 정의합니다.
package domain

import "time"

// TableInfo는 Oracle 테이블 메타데이터를 나타냅니다
type TableInfo struct {
        Name        string `json:"name"`         // 테이블 이름
        Owner       string `json:"owner"`        // 스키마 소유자
        RowCount    int64  `json:"row_count"`    // 테이블 row 수
        ColumnCount int    `json:"column_count"` // 컬럼 수
}

// ColumnInfo는 테이블 컬럼 메타데이터를 나타냅니다
type ColumnInfo struct {
        Name     string `json:"name"`      // 컬럼 이름
        DataType string `json:"data_type"` // 데이터 타입 (VARCHAR2, NUMBER 등)
        Nullable bool   `json:"nullable"`  // NULL 허용 여부
        Position int    `json:"position"`  // 컬럼 위치
}

// SampleData는 테이블 샘플 데이터 조회 결과를 나타냅니다
type SampleData struct {
        TableName string                   `json:"table"`   // 테이블 이름
        Columns   []string                 `json:"columns"` // 컬럼 이름 목록
        Rows      []map[string]interface{} `json:"rows"`    // 데이터 행
        Count     int                      `json:"count"`   // 반환된 row 수
}

// OracleStatus는 Oracle 연결 상태 정보를 나타냅니다
type OracleStatus struct {
        Connected       bool      `json:"connected"`       // 연결 상태
        DatabaseVersion string    `json:"database_version"` // 데이터베이스 버전
        InstanceName    string    `json:"instance_name"`   // 인스턴스 이름
        PoolStats       PoolStats `json:"pool_stats"`      // 커넥션 풀 통계
        CheckedAt       time.Time `json:"checked_at"`      // 상태 확인 시간
        Error           string    `json:"error,omitempty"` // 에러 메시지 (있는 경우)
}

// PoolStats는 커넥션 풀 통계를 나타냅니다
type PoolStats struct {
        ActiveConnections int `json:"active_connections"` // 사용 중인 연결 수
        IdleConnections   int `json:"idle_connections"`   // 유휴 연결 수
        MaxConnections    int `json:"max_connections"`    // 최대 연결 수
}

// TableListResponse는 GET /api/tables 응답 구조체입니다
type TableListResponse struct {
        Tables []TableInfo `json:"tables"` // 테이블 목록
        Total  int         `json:"total"`  // 총 테이블 수
}

// ChunkResult는 청크 단위 데이터 추출 결과를 나타냅니다
type ChunkResult struct {
        TableName     string                   `json:"table_name"`      // 테이블 이름
        ChunkNumber   int                      `json:"chunk_number"`    // 청크 번호
        Rows          []map[string]interface{} `json:"rows"`            // 데이터 행
        RowCount      int                      `json:"row_count"`       // 이 청크의 row 수
        IsLastChunk   bool                     `json:"is_last_chunk"`   // 마지막 청크 여부
        TotalRowsSent int64                    `json:"total_rows_sent"` // 지금까지 전송된 총 row 수
}

// ExtractionOptions는 데이터 추출 옵션을 나타냅니다
type ExtractionOptions struct {
        ChunkSize      int  `json:"chunk_size"`       // 청크당 row 수 (기본값: 10000)
        FetchArraySize int  `json:"fetch_array_size"` // 배치 페치 크기 (기본값: 1000)
        IncludeColumns bool `json:"include_columns"`  // 컬럼 정보 포함 여부
}

// DefaultExtractionOptions는 기본 추출 옵션을 반환합니다
func DefaultExtractionOptions() ExtractionOptions <span class="cov10" title="7">{
        return ExtractionOptions{
                ChunkSize:      10000,
                FetchArraySize: 1000,
                IncludeColumns: true,
        }
}</span>

// ExtractionStatus는 Extraction의 상태를 나타냅니다
type ExtractionStatus string

const (
        // ExtractionStatusPending은 대기 상태입니다
        ExtractionStatusPending ExtractionStatus = "pending"
        // ExtractionStatusRunning은 실행 중 상태입니다
        ExtractionStatusRunning ExtractionStatus = "running"
        // ExtractionStatusCompleted는 완료 상태입니다
        ExtractionStatusCompleted ExtractionStatus = "completed"
        // ExtractionStatusFailed는 실패 상태입니다
        ExtractionStatusFailed ExtractionStatus = "failed"
)

// Extraction은 단일 테이블 추출 결과를 나타냅니다
type Extraction struct {
        ID          string           `json:"id"`                     // 추출 ID
        JobID       string           `json:"job_id"`                 // 연결된 Job ID
        TableName   string           `json:"table_name"`             // 테이블 이름
        Status      ExtractionStatus `json:"status"`                 // 상태
        RowCount    int64            `json:"row_count"`              // 처리된 row 수
        ByteCount   int64            `json:"byte_count"`             // 전송된 바이트 수
        GCSPath     string           `json:"gcs_path,omitempty"`     // GCS 객체 경로
        StartedAt   *time.Time       `json:"started_at,omitempty"`   // 시작 시간
        CompletedAt *time.Time       `json:"completed_at,omitempty"` // 완료 시간
        Error       *string          `json:"error,omitempty"`        // 에러 메시지
}

// NewExtraction은 새로운 Extraction을 생성합니다
func NewExtraction(id, jobID, tableName string) *Extraction <span class="cov0" title="0">{
        return &amp;Extraction{
                ID:        id,
                JobID:     jobID,
                TableName: tableName,
                Status:    ExtractionStatusPending,
        }
}</span>

// Start는 Extraction을 시작 상태로 변경합니다
func (e *Extraction) Start() <span class="cov0" title="0">{
        now := time.Now().UTC()
        e.Status = ExtractionStatusRunning
        e.StartedAt = &amp;now
}</span>

// Complete는 Extraction을 완료 상태로 변경합니다
func (e *Extraction) Complete(rowCount, byteCount int64, gcsPath string) <span class="cov0" title="0">{
        now := time.Now().UTC()
        e.Status = ExtractionStatusCompleted
        e.CompletedAt = &amp;now
        e.RowCount = rowCount
        e.ByteCount = byteCount
        e.GCSPath = gcsPath
}</span>

// Fail은 Extraction을 실패 상태로 변경합니다
func (e *Extraction) Fail(err error) <span class="cov0" title="0">{
        now := time.Now().UTC()
        e.Status = ExtractionStatusFailed
        e.CompletedAt = &amp;now
        if err != nil </span><span class="cov0" title="0">{
                errStr := err.Error()
                e.Error = &amp;errStr
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package domain은 ETL 파이프라인의 핵심 도메인 모델을 정의합니다.
package domain

import (
        "fmt"
        "time"
)

// JobStatus는 Job의 상태를 나타냅니다
type JobStatus string

const (
        // JobStatusPending은 대기 상태입니다
        JobStatusPending JobStatus = "pending"
        // JobStatusRunning은 실행 중 상태입니다
        JobStatusRunning JobStatus = "running"
        // JobStatusCompleted는 완료 상태입니다
        JobStatusCompleted JobStatus = "completed"
        // JobStatusFailed는 실패 상태입니다
        JobStatusFailed JobStatus = "failed"
        // JobStatusCancelled은 취소 상태입니다
        JobStatusCancelled JobStatus = "cancelled"
)

// IsTerminal은 Job이 종료 상태인지 확인합니다
func (s JobStatus) IsTerminal() bool <span class="cov0" title="0">{
        return s == JobStatusCompleted || s == JobStatusFailed || s == JobStatusCancelled
}</span>

// JobMetrics는 Job 실행 메트릭을 나타냅니다
type JobMetrics struct {
        TotalRows     int64         `json:"total_rows"`      // 총 처리 row 수
        TotalBytes    int64         `json:"total_bytes"`     // 총 바이트 수
        Duration      time.Duration `json:"duration"`        // 실행 시간
        RowsPerSecond float64       `json:"rows_per_second"` // 초당 처리 row 수
}

// CalculateRowsPerSecond는 초당 처리 row 수를 계산합니다
func (m *JobMetrics) CalculateRowsPerSecond() <span class="cov2" title="2">{
        if m.Duration &gt; 0 </span><span class="cov2" title="2">{
                m.RowsPerSecond = float64(m.TotalRows) / m.Duration.Seconds()
        }</span>
}

// Job은 Transport의 단일 실행을 나타냅니다
type Job struct {
        ID          string       `json:"id"`                     // JOB-{timestamp}-{random}
        TransportID string       `json:"transport_id"`           // 연결된 Transport ID
        Version     int          `json:"version"`                // JOBVER: Transport별 증가
        Status      JobStatus    `json:"status"`                 // 현재 상태
        StartedAt   *time.Time   `json:"started_at,omitempty"`   // 시작 시간
        CompletedAt *time.Time   `json:"completed_at,omitempty"` // 완료 시간
        Extractions []Extraction `json:"extractions,omitempty"`  // 테이블별 추출 결과
        Error       *string      `json:"error,omitempty"`        // 에러 메시지
        Metrics     JobMetrics   `json:"metrics"`                // 실행 메트릭
        CreatedAt   time.Time    `json:"created_at"`             // 생성 시간
}

// GenerateJobID는 새로운 Job ID를 생성합니다
// 형식: JOB-{YYYYMMDD-HHMMSS}-{random}
func GenerateJobID(timestamp time.Time, randomPart string) string <span class="cov9" title="43">{
        return fmt.Sprintf("JOB-%s-%s", timestamp.Format("20060102-150405"), randomPart)
}</span>

// VersionString은 버전을 문자열로 반환합니다 (v001, v002, ...)
func (j *Job) VersionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("v%03d", j.Version)
}</span>

// NewJob은 새로운 Job을 생성합니다
func NewJob(id, transportID string, version int) *Job <span class="cov10" title="46">{
        now := time.Now().UTC()
        return &amp;Job{
                ID:          id,
                TransportID: transportID,
                Version:     version,
                Status:      JobStatusPending,
                Extractions: make([]Extraction, 0),
                Metrics:     JobMetrics{},
                CreatedAt:   now,
        }
}</span>

// Start는 Job을 시작 상태로 변경합니다
func (j *Job) Start() <span class="cov4" title="4">{
        now := time.Now().UTC()
        j.Status = JobStatusRunning
        j.StartedAt = &amp;now
}</span>

// Complete는 Job을 완료 상태로 변경합니다
func (j *Job) Complete() <span class="cov1" title="1">{
        now := time.Now().UTC()
        j.Status = JobStatusCompleted
        j.CompletedAt = &amp;now
        if j.StartedAt != nil </span><span class="cov1" title="1">{
                j.Metrics.Duration = now.Sub(*j.StartedAt)
                j.Metrics.CalculateRowsPerSecond()
        }</span>
}

// Fail은 Job을 실패 상태로 변경합니다
func (j *Job) Fail(err error) <span class="cov1" title="1">{
        now := time.Now().UTC()
        j.Status = JobStatusFailed
        j.CompletedAt = &amp;now
        if err != nil </span><span class="cov1" title="1">{
                errStr := err.Error()
                j.Error = &amp;errStr
        }</span>
        <span class="cov1" title="1">if j.StartedAt != nil </span><span class="cov1" title="1">{
                j.Metrics.Duration = now.Sub(*j.StartedAt)
                j.Metrics.CalculateRowsPerSecond()
        }</span>
}

// Cancel은 Job을 취소 상태로 변경합니다
func (j *Job) Cancel() <span class="cov0" title="0">{
        now := time.Now().UTC()
        j.Status = JobStatusCancelled
        j.CompletedAt = &amp;now
        if j.StartedAt != nil </span><span class="cov0" title="0">{
                j.Metrics.Duration = now.Sub(*j.StartedAt)
        }</span>
}

// AddExtraction은 Job에 Extraction을 추가합니다
func (j *Job) AddExtraction(ext Extraction) <span class="cov0" title="0">{
        j.Extractions = append(j.Extractions, ext)
}</span>

// UpdateMetrics는 Extractions 기반으로 메트릭을 업데이트합니다
func (j *Job) UpdateMetrics() <span class="cov0" title="0">{
        var totalRows, totalBytes int64
        for _, ext := range j.Extractions </span><span class="cov0" title="0">{
                totalRows += ext.RowCount
                totalBytes += ext.ByteCount
        }</span>
        <span class="cov0" title="0">j.Metrics.TotalRows = totalRows
        j.Metrics.TotalBytes = totalBytes
        j.Metrics.CalculateRowsPerSecond()</span>
}

// ExecuteJobResponse는 Job 실행 응답입니다
type ExecuteJobResponse struct {
        JobID       string    `json:"job_id"`
        TransportID string    `json:"transport_id"`
        Version     int       `json:"version"`
        Status      JobStatus `json:"status"`
}

// JobListResponse는 Job 목록 응답입니다
type JobListResponse struct {
        Jobs   []Job `json:"jobs"`
        Total  int   `json:"total"`
        Offset int   `json:"offset"`
        Limit  int   `json:"limit"`
}

// JobListFilter는 Job 목록 조회 필터입니다
type JobListFilter struct {
        TransportID string    `json:"transport_id,omitempty"`
        Status      JobStatus `json:"status,omitempty"`
        Limit       int       `json:"limit"`
        Offset      int       `json:"offset"`
}

// DefaultJobListFilter는 기본 필터를 반환합니다
func DefaultJobListFilter() JobListFilter <span class="cov6" title="10">{
        return JobListFilter{
                Limit:  20,
                Offset: 0,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package domain은 ETL 파이프라인의 핵심 도메인 모델을 정의합니다.
package domain

import (
        "fmt"
        "strings"
        "time"
)

// TransportStatus는 Transport의 상태를 나타냅니다
type TransportStatus string

const (
        // TransportStatusIdle은 대기 상태입니다
        TransportStatusIdle TransportStatus = "idle"
        // TransportStatusRunning은 실행 중 상태입니다
        TransportStatusRunning TransportStatus = "running"
        // TransportStatusFailed는 실패 상태입니다
        TransportStatusFailed TransportStatus = "failed"
)

// CronSchedule은 스케줄 설정을 나타냅니다
type CronSchedule struct {
        Expression string `json:"expression"` // cron 표현식
        Timezone   string `json:"timezone"`   // 시간대 (예: "Asia/Seoul")
}

// Transport는 ETL 전송 구성을 나타냅니다
type Transport struct {
        ID          string          `json:"id"`                    // TRPID-xxx 형식
        Name        string          `json:"name"`                  // Transport 이름
        Description string          `json:"description,omitempty"` // 설명
        Tables      []string        `json:"tables"`                // 대상 테이블 목록
        Enabled     bool            `json:"enabled"`               // 활성화 여부
        Schedule    *CronSchedule   `json:"schedule,omitempty"`    // 선택적 cron 스케줄
        Status      TransportStatus `json:"status"`                // 현재 상태
        CreatedAt   time.Time       `json:"created_at"`            // 생성 시간
        UpdatedAt   time.Time       `json:"updated_at"`            // 수정 시간
}

// GenerateTransportID는 새로운 Transport ID를 생성합니다
// 형식: TRPID-{uuid의 처음 8자}
func GenerateTransportID(uuidStr string) string <span class="cov8" title="25">{
        // uuid가 하이픈을 포함하는 경우 제거
        cleanUUID := strings.ReplaceAll(uuidStr, "-", "")
        if len(cleanUUID) &gt;= 8 </span><span class="cov8" title="20">{
                return fmt.Sprintf("TRPID-%s", cleanUUID[:8])
        }</span>
        <span class="cov4" title="5">return fmt.Sprintf("TRPID-%s", cleanUUID)</span>
}

// NewTransport는 새로운 Transport를 생성합니다
func NewTransport(id, name, description string, tables []string) *Transport <span class="cov10" title="39">{
        now := time.Now().UTC()
        return &amp;Transport{
                ID:          id,
                Name:        name,
                Description: description,
                Tables:      tables,
                Enabled:     true,
                Status:      TransportStatusIdle,
                CreatedAt:   now,
                UpdatedAt:   now,
        }
}</span>

// Validate는 Transport의 유효성을 검사합니다
func (t *Transport) Validate() error <span class="cov0" title="0">{
        if t.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("transport ID가 비어있습니다")
        }</span>
        <span class="cov0" title="0">if t.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("transport 이름이 비어있습니다")
        }</span>
        <span class="cov0" title="0">if len(t.Tables) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("테이블 목록이 비어있습니다")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CanExecute는 Transport가 실행 가능한지 확인합니다
func (t *Transport) CanExecute() bool <span class="cov6" title="8">{
        return t.Enabled &amp;&amp; t.Status != TransportStatusRunning
}</span>

// CreateTransportRequest는 Transport 생성 요청 DTO입니다
type CreateTransportRequest struct {
        Name        string   `json:"name"`
        Description string   `json:"description,omitempty"`
        Tables      []string `json:"tables"`
}

// Validate는 요청의 유효성을 검사합니다
func (r *CreateTransportRequest) Validate() error <span class="cov8" title="23">{
        if r.Name == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("name은 필수입니다")
        }</span>
        <span class="cov8" title="21">if len(r.Tables) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("tables는 최소 1개 이상이어야 합니다")
        }</span>
        <span class="cov8" title="20">return nil</span>
}

// TransportListResponse는 Transport 목록 응답입니다
type TransportListResponse struct {
        Transports []Transport `json:"transports"`
        Total      int         `json:"total"`
        Offset     int         `json:"offset"`
        Limit      int         `json:"limit"`
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package errors는 구조화된 에러 처리를 제공합니다.
// M7-01: 표준 에러 응답 포맷
package errors

import (
        "fmt"
        "net/http"
)

// 에러 코드 상수
const (
        // ErrCodeOracleConnection은 Oracle 연결 오류를 나타냅니다
        ErrCodeOracleConnection = "ORACLE_CONNECTION_ERROR"
        // ErrCodeGCSUpload은 GCS 업로드 오류를 나타냅니다
        ErrCodeGCSUpload = "GCS_UPLOAD_ERROR"
        // ErrCodeTransportNotFound는 Transport를 찾을 수 없음을 나타냅니다
        ErrCodeTransportNotFound = "TRANSPORT_NOT_FOUND"
        // ErrCodeValidation은 유효성 검사 오류를 나타냅니다
        ErrCodeValidation = "VALIDATION_ERROR"
        // ErrCodeAuth는 인증 오류를 나타냅니다
        ErrCodeAuth = "AUTHENTICATION_ERROR"
        // ErrCodeRateLimit은 요청 제한 초과를 나타냅니다
        ErrCodeRateLimit = "RATE_LIMIT_EXCEEDED"
        // ErrCodeInternal은 내부 서버 오류를 나타냅니다
        ErrCodeInternal = "INTERNAL_ERROR"
)

// ErrorResponse는 구조화된 에러 응답 구조체입니다
type ErrorResponse struct {
        Code    string `json:"code"`              // 에러 코드 (예: ORACLE_CONNECTION_ERROR)
        Message string `json:"message"`           // 사용자 친화적 메시지
        Details any    `json:"details,omitempty"` // 추가 상세 정보 (선택)
        TraceID string `json:"trace_id,omitempty"` // 추적 ID (선택)
}

// NewError는 새로운 ErrorResponse를 생성합니다
func NewError(code, message string) *ErrorResponse <span class="cov10" title="21">{
        return &amp;ErrorResponse{
                Code:    code,
                Message: message,
        }
}</span>

// WithDetails는 상세 정보를 추가하고 체이닝을 위해 자신을 반환합니다
func (e *ErrorResponse) WithDetails(details any) *ErrorResponse <span class="cov5" title="5">{
        e.Details = details
        return e
}</span>

// WithTraceID는 TraceID를 추가하고 체이닝을 위해 자신을 반환합니다
func (e *ErrorResponse) WithTraceID(traceID string) *ErrorResponse <span class="cov4" title="3">{
        e.TraceID = traceID
        return e
}</span>

// Error는 error 인터페이스를 구현합니다
func (e *ErrorResponse) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}</span>

// Is는 errors.Is 지원을 위한 메서드입니다
// 에러 코드가 같으면 동일한 에러로 간주합니다
func (e *ErrorResponse) Is(target error) bool <span class="cov3" title="2">{
        t, ok := target.(*ErrorResponse)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="2">return e.Code == t.Code</span>
}

// HTTPStatus는 에러 코드에 따른 HTTP 상태 코드를 반환합니다
func (e *ErrorResponse) HTTPStatus() int <span class="cov6" title="7">{
        switch e.Code </span>{
        case ErrCodeValidation:<span class="cov1" title="1">
                return http.StatusBadRequest</span> // 400
        case ErrCodeAuth:<span class="cov1" title="1">
                return http.StatusUnauthorized</span> // 401
        case ErrCodeTransportNotFound:<span class="cov1" title="1">
                return http.StatusNotFound</span> // 404
        case ErrCodeRateLimit:<span class="cov1" title="1">
                return http.StatusTooManyRequests</span> // 429
        case ErrCodeOracleConnection:<span class="cov1" title="1">
                return http.StatusServiceUnavailable</span> // 503
        case ErrCodeGCSUpload:<span class="cov1" title="1">
                return http.StatusBadGateway</span> // 502
        case ErrCodeInternal:<span class="cov1" title="1">
                return http.StatusInternalServerError</span> // 500
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span> // 500
        }
}

// FromError는 표준 error에서 ErrorResponse를 생성합니다
func FromError(code string, err error) *ErrorResponse <span class="cov3" title="2">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return NewError(code, err.Error())</span>
}

// NewValidationError는 유효성 검사 에러를 생성합니다
func NewValidationError(field, message string) *ErrorResponse <span class="cov1" title="1">{
        return NewError(ErrCodeValidation, message).
                WithDetails(map[string]any{
                        "field": field,
                })
}</span>

// NewOracleConnectionError는 Oracle 연결 에러를 생성합니다
func NewOracleConnectionError(cause error) *ErrorResponse <span class="cov1" title="1">{
        msg := "Oracle 데이터베이스 연결 실패"
        if cause != nil </span><span class="cov1" title="1">{
                msg = fmt.Sprintf("Oracle 연결 오류: %v", cause)
        }</span>
        <span class="cov1" title="1">return NewError(ErrCodeOracleConnection, msg).
                WithDetails(map[string]any{
                        "cause": cause.Error(),
                })</span>
}

// NewGCSUploadError는 GCS 업로드 에러를 생성합니다
func NewGCSUploadError(path string, cause error) *ErrorResponse <span class="cov1" title="1">{
        msg := "GCS 업로드 실패"
        if cause != nil </span><span class="cov1" title="1">{
                msg = fmt.Sprintf("GCS 업로드 오류: %v", cause)
        }</span>
        <span class="cov1" title="1">return NewError(ErrCodeGCSUpload, msg).
                WithDetails(map[string]any{
                        "path":  path,
                        "cause": cause.Error(),
                })</span>
}

// NewNotFoundError는 리소스 미발견 에러를 생성합니다
func NewNotFoundError(resourceType, id string) *ErrorResponse <span class="cov1" title="1">{
        return NewError(ErrCodeTransportNotFound,
                fmt.Sprintf("%s '%s'을(를) 찾을 수 없습니다", resourceType, id))
}</span>

// NewAuthError는 인증 에러를 생성합니다
func NewAuthError(message string) *ErrorResponse <span class="cov0" title="0">{
        return NewError(ErrCodeAuth, message)
}</span>

// NewRateLimitError는 요청 제한 에러를 생성합니다
func NewRateLimitError() *ErrorResponse <span class="cov0" title="0">{
        return NewError(ErrCodeRateLimit, "요청 제한 초과. 잠시 후 다시 시도해주세요.")
}</span>

// NewInternalError는 내부 서버 에러를 생성합니다
func NewInternalError(message string) *ErrorResponse <span class="cov0" title="0">{
        return NewError(ErrCodeInternal, message)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package middleware는 HTTP 요청 처리를 위한 미들웨어를 제공합니다
package middleware

import (
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/golang-jwt/jwt/v5"

        "oracle-etl/internal/config"
)

// 인증 제외 경로 목록
var skipAuthPaths = []string{
        "/api/health",
        "/health",
}

// NewAuthMiddleware는 API Key 및 Bearer Token 인증 미들웨어를 생성합니다
func NewAuthMiddleware(cfg *config.AuthConfig) fiber.Handler <span class="cov8" title="11">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="12">{
                // 인증이 비활성화된 경우 통과
                if !cfg.Enabled </span><span class="cov1" title="1">{
                        return c.Next()
                }</span>

                // 인증 제외 경로 확인
                <span class="cov8" title="11">path := c.Path()
                for _, skipPath := range skipAuthPaths </span><span class="cov10" title="21">{
                        if path == skipPath </span><span class="cov1" title="1">{
                                return c.Next()
                        }</span>
                }

                // API Key 확인
                <span class="cov7" title="10">apiKey := c.Get("X-API-Key")
                if apiKey != "" </span><span class="cov4" title="3">{
                        if validateAPIKey(apiKey, cfg.APIKeys) </span><span class="cov3" title="2">{
                                c.Locals("auth_method", "api_key")
                                return c.Next()
                        }</span>
                        <span class="cov1" title="1">return authError(c, "유효하지 않은 API Key")</span>
                }

                // Bearer Token 확인
                <span class="cov6" title="7">authHeader := c.Get("Authorization")
                if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov6" title="6">{
                        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                        claims, err := validateBearerToken(tokenString, cfg.BearerSecret)
                        if err != nil </span><span class="cov4" title="3">{
                                return authError(c, "유효하지 않은 Bearer Token: "+err.Error())
                        }</span>

                        // 사용자 정보를 컨텍스트에 저장
                        <span class="cov4" title="3">if sub, ok := claims["sub"].(string); ok </span><span class="cov4" title="3">{
                                c.Locals("user_id", sub)
                        }</span>
                        <span class="cov4" title="3">c.Locals("auth_method", "bearer")
                        return c.Next()</span>
                }

                // 인증 정보 없음
                <span class="cov1" title="1">return authError(c, "인증 정보가 필요합니다")</span>
        }
}

// validateAPIKey는 제공된 API Key가 유효한지 확인합니다
func validateAPIKey(key string, validKeys []string) bool <span class="cov4" title="3">{
        for _, validKey := range validKeys </span><span class="cov4" title="3">{
                if key == validKey </span><span class="cov3" title="2">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// validateBearerToken는 JWT 토큰을 검증하고 클레임을 반환합니다
func validateBearerToken(tokenString, secret string) (jwt.MapClaims, error) <span class="cov6" title="6">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov5" title="5">{
                // HMAC 서명 방식 확인
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, jwt.ErrSignatureInvalid
                }</span>
                <span class="cov5" title="5">return []byte(secret), nil</span>
        })

        <span class="cov6" title="6">if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov4" title="3">if !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrSignatureInvalid
        }</span>

        <span class="cov4" title="3">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, jwt.ErrTokenMalformed
        }</span>

        <span class="cov4" title="3">return claims, nil</span>
}

// authError는 인증 실패 응답을 반환합니다
func authError(c *fiber.Ctx, message string) error <span class="cov5" title="5">{
        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                "code":    "AUTHENTICATION_ERROR",
                "message": message,
        })
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package middleware는 HTTP 미들웨어를 제공합니다.
// M6-05: CORS 설정
package middleware

import (
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"

        "oracle-etl/internal/config"
)

// NewCORSMiddleware는 CORS 미들웨어를 생성합니다
func NewCORSMiddleware(cfg *config.CORSConfig) fiber.Handler <span class="cov10" title="11">{
        if cfg == nil || !cfg.Enabled </span><span class="cov1" title="1">{
                // CORS 비활성화 - 아무 작업도 하지 않음
                return func(c *fiber.Ctx) error </span><span class="cov1" title="1">{
                        return c.Next()
                }</span>
        }

        // 오리진 문자열 결합
        <span class="cov9" title="10">origins := strings.Join(cfg.AllowOrigins, ", ")

        // 메서드 문자열 결합
        methods := strings.Join(cfg.AllowMethods, ", ")

        // 헤더 문자열 결합
        headers := strings.Join(cfg.AllowHeaders, ", ")

        // 노출 헤더 문자열 결합
        exposeHeaders := strings.Join(cfg.ExposeHeaders, ", ")

        return cors.New(cors.Config{
                AllowOrigins:     origins,
                AllowMethods:     methods,
                AllowHeaders:     headers,
                AllowCredentials: cfg.AllowCredentials,
                ExposeHeaders:    exposeHeaders,
                MaxAge:           cfg.MaxAge,
        })</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package middleware는 HTTP 요청 처리를 위한 미들웨어를 제공합니다
package middleware

import (
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/rs/zerolog"
)

// NewLoggingMiddleware는 구조화된 JSON 로깅 미들웨어를 생성합니다
func NewLoggingMiddleware(logger zerolog.Logger) fiber.Handler <span class="cov10" title="3">{
        return func(c *fiber.Ctx) error </span><span class="cov10" title="3">{
                start := time.Now()

                // 요청 ID 생성
                requestID := uuid.New().String()
                c.Locals("request_id", requestID)

                // 다음 핸들러 실행
                err := c.Next()

                // 응답 후 로깅
                latency := time.Since(start)
                status := c.Response().StatusCode()

                // 로그 레벨 결정
                var event *zerolog.Event
                if status &gt;= 500 </span><span class="cov1" title="1">{
                        event = logger.Error()
                }</span> else<span class="cov6" title="2"> if status &gt;= 400 </span><span class="cov0" title="0">{
                        event = logger.Warn()
                }</span> else<span class="cov6" title="2"> {
                        event = logger.Info()
                }</span>

                <span class="cov10" title="3">event.
                        Str("request_id", requestID).
                        Str("method", c.Method()).
                        Str("path", c.Path()).
                        Int("status", status).
                        Str("latency", latency.String()).
                        Msg("request completed")

                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "regexp"
        "strings"
)

// 민감 데이터 패턴 정규식
var (
        // 연결 문자열에서 비밀번호 (protocol://user:password@host)
        // [^:]*를 사용하여 빈 사용자 이름도 허용 (예: redis://:password@host)
        connectionPasswordPattern = regexp.MustCompile(`(://[^:]*:)([^@]+)(@)`)

        // key=value 형식 패턴들
        passwordPattern      = regexp.MustCompile(`(?i)(password|passwd|pwd)\s*=\s*[^\s&amp;]+`)
        apiKeyPattern        = regexp.MustCompile(`(?i)(api[_-]?key|x-api-key)\s*=\s*[^\s&amp;]+`)
        tokenPattern         = regexp.MustCompile(`(?i)(access[_-]?token|refresh[_-]?token|token)\s*=\s*[^\s&amp;]+`)
        secretPattern        = regexp.MustCompile(`(?i)(secret|secret[_-]?key|client[_-]?secret)\s*=\s*[^\s&amp;]+`)
        authorizationPattern = regexp.MustCompile(`(?i)(authorization)\s*=\s*[^\s&amp;]+`)

        // credentials 패턴 - 값에 공백이 있을 수 있음 (예: -----BEGIN RSA PRIVATE KEY-----)
        // 줄 끝까지 또는 다음 key= 패턴 전까지 캡처
        credentialsPattern = regexp.MustCompile(`(?i)(credentials|private[_-]?key)\s*=\s*(.+?)(?:\s+\w+=|$)`)

        // Bearer 토큰 패턴
        bearerPattern = regexp.MustCompile(`(?i)(bearer)\s+[^\s]+`)

        // Authorization 헤더 패턴 (Bearer 외의 다른 인증 방식)
        authHeaderPattern = regexp.MustCompile(`(?i)(Authorization:)\s+(Basic|Digest)\s+[^\s]+`)
)

// MaskSensitiveData는 입력 문자열에서 민감한 정보를 마스킹합니다
// 비밀번호, API 키, 토큰, 자격증명 등을 "****"로 대체합니다
func MaskSensitiveData(input string) string <span class="cov7" title="26">{
        if input == "" </span><span class="cov1" title="1">{
                return input
        }</span>

        <span class="cov7" title="25">result := input

        // 연결 문자열 비밀번호 마스킹 (protocol://user:password@host)
        result = connectionPasswordPattern.ReplaceAllString(result, "${1}****${3}")

        // Bearer 토큰 마스킹
        result = bearerPattern.ReplaceAllStringFunc(result, func(match string) string </span><span class="cov2" title="2">{
                parts := strings.SplitN(match, " ", 2)
                if len(parts) == 2 </span><span class="cov2" title="2">{
                        return parts[0] + " ****"
                }</span>
                <span class="cov0" title="0">return match</span>
        })

        // Authorization 헤더 마스킹 (Basic, Digest 등)
        <span class="cov7" title="25">result = authHeaderPattern.ReplaceAllStringFunc(result, func(match string) string </span><span class="cov1" title="1">{
                // "Authorization: Basic xxx" -&gt; "Authorization: ****"
                if idx := strings.Index(strings.ToLower(match), "authorization:"); idx != -1 </span><span class="cov1" title="1">{
                        return match[:idx+14] + " ****"
                }</span>
                <span class="cov0" title="0">return "Authorization: ****"</span>
        })

        // credentials 패턴 마스킹 (값에 공백이 있을 수 있음)
        <span class="cov7" title="25">result = credentialsPattern.ReplaceAllStringFunc(result, func(match string) string </span><span class="cov2" title="2">{
                eqIdx := strings.Index(match, "=")
                if eqIdx == -1 </span><span class="cov0" title="0">{
                        return match
                }</span>
                // 끝에 다음 key= 패턴이 있는지 확인
                <span class="cov2" title="2">afterEq := match[eqIdx+1:]
                // 공백과 key= 패턴이 있으면 그 부분은 유지
                if spaceIdx := strings.LastIndex(afterEq, " "); spaceIdx != -1 </span><span class="cov1" title="1">{
                        remaining := strings.TrimSpace(afterEq[spaceIdx:])
                        if strings.Contains(remaining, "=") </span><span class="cov0" title="0">{
                                return match[:eqIdx+1] + "****" + afterEq[spaceIdx:]
                        }</span>
                }
                <span class="cov2" title="2">return match[:eqIdx+1] + "****"</span>
        })

        // key=value 패턴 마스킹
        <span class="cov7" title="25">result = maskKeyValuePattern(result, passwordPattern)
        result = maskKeyValuePattern(result, apiKeyPattern)
        result = maskKeyValuePattern(result, tokenPattern)
        result = maskKeyValuePattern(result, secretPattern)
        result = maskKeyValuePattern(result, authorizationPattern)

        return result</span>
}

// maskKeyValuePattern는 key=value 패턴을 마스킹합니다
func maskKeyValuePattern(input string, pattern *regexp.Regexp) string <span class="cov10" title="125">{
        return pattern.ReplaceAllStringFunc(input, func(match string) string </span><span class="cov6" title="17">{
                // "key=value" -&gt; "key=****"
                eqIdx := strings.Index(match, "=")
                if eqIdx == -1 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov6" title="17">return match[:eqIdx+1] + "****"</span>
        })
}

// MaskConnectionString는 데이터베이스 연결 문자열에서 비밀번호를 마스킹합니다
func MaskConnectionString(connStr string) string <span class="cov3" title="3">{
        return connectionPasswordPattern.ReplaceAllString(connStr, "${1}****${3}")
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "strconv"
        "sync"
        "time"

        "github.com/gofiber/fiber/v2"

        "oracle-etl/internal/config"
)

// rateLimiter는 토큰 버킷 기반 Rate Limiter입니다
type rateLimiter struct {
        mu                sync.RWMutex
        buckets           map[string]*tokenBucket
        requestsPerMinute int
        burstSize         int
}

// tokenBucket은 토큰 버킷을 나타냅니다
type tokenBucket struct {
        tokens     float64
        lastUpdate time.Time
}

// newRateLimiter는 새로운 Rate Limiter를 생성합니다
func newRateLimiter(requestsPerMinute, burstSize int) *rateLimiter <span class="cov4" title="7">{
        rl := &amp;rateLimiter{
                buckets:           make(map[string]*tokenBucket),
                requestsPerMinute: requestsPerMinute,
                burstSize:         burstSize,
        }

        // 주기적으로 오래된 버킷 정리
        go rl.cleanup()

        return rl
}</span>

// cleanup은 오래된 버킷을 주기적으로 정리합니다
func (rl *rateLimiter) cleanup() <span class="cov4" title="7">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                rl.mu.Lock()
                now := time.Now()
                for key, bucket := range rl.buckets </span><span class="cov0" title="0">{
                        if now.Sub(bucket.lastUpdate) &gt; 10*time.Minute </span><span class="cov0" title="0">{
                                delete(rl.buckets, key)
                        }</span>
                }
                <span class="cov0" title="0">rl.mu.Unlock()</span>
        }
}

// allow는 요청이 허용되는지 확인하고 토큰을 소비합니다
func (rl *rateLimiter) allow(key string) (allowed bool, remaining int, resetIn time.Duration) <span class="cov5" title="12">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        bucket, exists := rl.buckets[key]

        if !exists </span><span class="cov5" title="9">{
                bucket = &amp;tokenBucket{
                        tokens:     float64(rl.burstSize),
                        lastUpdate: now,
                }
                rl.buckets[key] = bucket
        }</span>

        // 시간 경과에 따른 토큰 리필
        <span class="cov5" title="12">elapsed := now.Sub(bucket.lastUpdate)
        tokensPerSecond := float64(rl.requestsPerMinute) / 60.0
        bucket.tokens += elapsed.Seconds() * tokensPerSecond

        // 최대 버스트 크기로 제한
        if bucket.tokens &gt; float64(rl.burstSize) </span><span class="cov0" title="0">{
                bucket.tokens = float64(rl.burstSize)
        }</span>

        <span class="cov5" title="12">bucket.lastUpdate = now

        // 토큰 소비 시도
        if bucket.tokens &gt;= 1 </span><span class="cov5" title="9">{
                bucket.tokens--
                remaining = int(bucket.tokens)
                return true, remaining, 0
        }</span>

        // 토큰 부족 - 다음 토큰까지 대기 시간 계산
        <span class="cov3" title="3">tokensNeeded := 1 - bucket.tokens
        resetIn = time.Duration(tokensNeeded/tokensPerSecond*1000) * time.Millisecond

        return false, 0, resetIn</span>
}

// NewRateLimitMiddleware는 Rate Limiting 미들웨어를 생성합니다
func NewRateLimitMiddleware(cfg *config.RateLimitConfig) fiber.Handler <span class="cov5" title="8">{
        // 비활성화된 경우 패스스루
        if !cfg.Enabled </span><span class="cov1" title="1">{
                return func(c *fiber.Ctx) error </span><span class="cov10" title="100">{
                        return c.Next()
                }</span>
        }

        <span class="cov4" title="7">limiter := newRateLimiter(cfg.RequestsPerMinute, cfg.BurstSize)

        return func(c *fiber.Ctx) error </span><span class="cov5" title="12">{
                // 요청 식별자 생성 (API Key 또는 IP)
                key := getRequestKey(c)

                allowed, remaining, resetIn := limiter.allow(key)

                // Rate Limit 헤더 설정
                c.Set("X-RateLimit-Limit", strconv.Itoa(cfg.RequestsPerMinute))
                c.Set("X-RateLimit-Remaining", strconv.Itoa(remaining))

                if !allowed </span><span class="cov3" title="3">{
                        // 제한 초과
                        retryAfterSeconds := int(resetIn.Seconds())
                        if retryAfterSeconds &lt; 1 </span><span class="cov0" title="0">{
                                retryAfterSeconds = 1
                        }</span>
                        <span class="cov3" title="3">c.Set("Retry-After", strconv.Itoa(retryAfterSeconds))
                        c.Set("X-RateLimit-Reset", strconv.FormatInt(time.Now().Add(resetIn).Unix(), 10))

                        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
                                "code":        "RATE_LIMIT_EXCEEDED",
                                "message":     "요청 제한을 초과했습니다. 잠시 후 다시 시도하세요.",
                                "retry_after": retryAfterSeconds,
                        })</span>
                }

                <span class="cov5" title="9">return c.Next()</span>
        }
}

// getRequestKey는 요청 식별자를 생성합니다
func getRequestKey(c *fiber.Ctx) string <span class="cov5" title="12">{
        // API Key가 있으면 우선 사용
        apiKey := c.Get("X-API-Key")
        if apiKey != "" </span><span class="cov2" title="2">{
                return "apikey:" + apiKey
        }</span>

        // X-Forwarded-For 헤더 확인 (프록시 환경)
        <span class="cov5" title="10">forwardedFor := c.Get("X-Forwarded-For")
        if forwardedFor != "" </span><span class="cov5" title="10">{
                return "ip:" + forwardedFor
        }</span>

        // 직접 연결 IP
        <span class="cov0" title="0">return "ip:" + c.IP()</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package middleware는 HTTP 미들웨어를 제공합니다.
// M7-05: Enhanced Panic Recovery
package middleware

import (
        "fmt"
        "runtime/debug"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/rs/zerolog"

        apperrors "oracle-etl/internal/errors"
)

// NewRecoveryMiddleware는 개선된 패닉 복구 미들웨어를 생성합니다
// - 구조화된 에러 응답 (ErrorResponse)
// - TraceID 지원
// - 요청 컨텍스트 로깅
// - error 타입 패닉 처리
func NewRecoveryMiddleware(logger zerolog.Logger) fiber.Handler <span class="cov10" title="8">{
        return func(c *fiber.Ctx) error </span><span class="cov10" title="8">{
                defer func() </span><span class="cov10" title="8">{
                        if r := recover(); r != nil </span><span class="cov9" title="7">{
                                // TraceID 추출 또는 생성
                                traceID := c.Get("X-Request-ID")
                                if traceID == "" </span><span class="cov8" title="6">{
                                        traceID = uuid.New().String()
                                }</span>

                                // 스택 트레이스 캡처
                                <span class="cov9" title="7">stack := debug.Stack()

                                // 패닉 값에서 에러 정보 추출
                                errResp := extractError(r, traceID)

                                // 요청 컨텍스트와 함께 패닉 로깅
                                logger.Error().
                                        Str("panic", fmt.Sprintf("%v", r)).
                                        Str("stack", string(stack)).
                                        Str("trace_id", traceID).
                                        Str("method", c.Method()).
                                        Str("path", c.Path()).
                                        Str("ip", c.IP()).
                                        Str("user_agent", c.Get("User-Agent")).
                                        Msg("panic recovered")

                                // JSON 에러 응답 반환
                                c.Status(errResp.HTTPStatus())
                                _ = c.JSON(errResp)</span>
                        }
                }()

                <span class="cov10" title="8">return c.Next()</span>
        }
}

// extractError는 패닉 값에서 ErrorResponse를 추출합니다
func extractError(r any, traceID string) *apperrors.ErrorResponse <span class="cov9" title="7">{
        // ErrorResponse 타입인 경우
        if errResp, ok := r.(*apperrors.ErrorResponse); ok </span><span class="cov1" title="1">{
                return errResp.WithTraceID(traceID)
        }</span>

        // 일반 error 타입인 경우
        <span class="cov8" title="6">if err, ok := r.(error); ok </span><span class="cov0" title="0">{
                return apperrors.NewError(apperrors.ErrCodeInternal, err.Error()).
                        WithTraceID(traceID)
        }</span>

        // 문자열 또는 기타 타입인 경우
        <span class="cov8" title="6">return apperrors.NewError(apperrors.ErrCodeInternal, "Internal Server Error").
                WithTraceID(traceID).
                WithDetails(map[string]any{
                        "panic_value": fmt.Sprintf("%v", r),
                })</span>
}

// NewRecoveryMiddlewareWithConfig는 설정 가능한 패닉 복구 미들웨어를 생성합니다
func NewRecoveryMiddlewareWithConfig(logger zerolog.Logger, config RecoveryConfig) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                // TraceID 추출 또는 생성
                                traceID := c.Get(config.TraceIDHeader)
                                if traceID == "" </span><span class="cov0" title="0">{
                                        traceID = uuid.New().String()
                                }</span>

                                // 스택 트레이스 캡처
                                <span class="cov0" title="0">stack := debug.Stack()

                                // 패닉 값에서 에러 정보 추출
                                errResp := extractError(r, traceID)

                                // 로깅
                                logEvent := logger.Error().
                                        Str("panic", fmt.Sprintf("%v", r)).
                                        Str("trace_id", traceID).
                                        Str("method", c.Method()).
                                        Str("path", c.Path())

                                if config.EnableStackTrace </span><span class="cov0" title="0">{
                                        logEvent = logEvent.Str("stack", string(stack))
                                }</span>

                                <span class="cov0" title="0">logEvent.Msg("panic recovered")

                                // 콜백 호출 (있는 경우)
                                if config.OnPanic != nil </span><span class="cov0" title="0">{
                                        config.OnPanic(c, r, stack)
                                }</span>

                                // JSON 에러 응답 반환
                                <span class="cov0" title="0">c.Status(errResp.HTTPStatus())
                                _ = c.JSON(errResp)</span>
                        }
                }()

                <span class="cov0" title="0">return c.Next()</span>
        }
}

// RecoveryConfig는 패닉 복구 미들웨어 설정입니다
type RecoveryConfig struct {
        // TraceIDHeader는 TraceID를 추출할 헤더 이름입니다 (기본: X-Request-ID)
        TraceIDHeader string
        // EnableStackTrace는 스택 트레이스 로깅 활성화 여부입니다
        EnableStackTrace bool
        // OnPanic은 패닉 발생 시 호출되는 콜백입니다
        OnPanic func(c *fiber.Ctx, panicValue any, stack []byte)
}

// DefaultRecoveryConfig는 기본 설정을 반환합니다
func DefaultRecoveryConfig() RecoveryConfig <span class="cov0" title="0">{
        return RecoveryConfig{
                TraceIDHeader:    "X-Request-ID",
                EnableStackTrace: true,
                OnPanic:          nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package memory는 개발 및 테스트용 인메모리 저장소 구현을 제공합니다.
package memory

import (
        "context"
        "fmt"
        "sort"
        "sync"

        "oracle-etl/internal/domain"
        "oracle-etl/internal/repository"
)

// JobRepository는 인메모리 Job 저장소 구현입니다
type JobRepository struct {
        mu   sync.RWMutex
        jobs map[string]*domain.Job
}

// NewJobRepository는 새로운 인메모리 Job 저장소를 생성합니다
func NewJobRepository() repository.JobRepository <span class="cov6" title="8">{
        return &amp;JobRepository{
                jobs: make(map[string]*domain.Job),
        }
}</span>

// Create는 새로운 Job을 생성합니다
func (r *JobRepository) Create(ctx context.Context, job *domain.Job) error <span class="cov10" title="23">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.jobs[job.ID]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("job ID '%s'가 이미 존재합니다", job.ID)
        }</span>

        // 복사본 저장
        <span class="cov9" title="22">copied := *job
        copied.Extractions = make([]domain.Extraction, len(job.Extractions))
        copy(copied.Extractions, job.Extractions)
        r.jobs[job.ID] = &amp;copied

        return nil</span>
}

// GetByID는 ID로 Job을 조회합니다
func (r *JobRepository) GetByID(ctx context.Context, id string) (*domain.Job, error) <span class="cov4" title="3">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        job, exists := r.jobs[id]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("job ID '%s'를 찾을 수 없습니다", id)
        }</span>

        // 복사본 반환
        <span class="cov2" title="2">copied := *job
        copied.Extractions = make([]domain.Extraction, len(job.Extractions))
        copy(copied.Extractions, job.Extractions)
        return &amp;copied, nil</span>
}

// List는 필터에 따라 Job 목록을 조회합니다
func (r *JobRepository) List(ctx context.Context, filter domain.JobListFilter) ([]domain.Job, int, error) <span class="cov4" title="4">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // 필터 적용
        list := make([]domain.Job, 0)
        for _, j := range r.jobs </span><span class="cov8" title="13">{
                // TransportID 필터
                if filter.TransportID != "" &amp;&amp; j.TransportID != filter.TransportID </span><span class="cov2" title="2">{
                        continue</span>
                }
                // Status 필터
                <span class="cov7" title="11">if filter.Status != "" &amp;&amp; j.Status != filter.Status </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov7" title="10">list = append(list, *j)</span>
        }

        // 생성 시간 기준 정렬 (최신순)
        <span class="cov4" title="4">sort.Slice(list, func(i, j int) bool </span><span class="cov8" title="14">{
                return list[i].CreatedAt.After(list[j].CreatedAt)
        }</span>)

        <span class="cov4" title="4">total := len(list)

        // offset/limit 적용
        if filter.Offset &gt;= len(list) </span><span class="cov1" title="1">{
                return []domain.Job{}, total, nil
        }</span>

        <span class="cov4" title="3">end := filter.Offset + filter.Limit
        if end &gt; len(list) </span><span class="cov2" title="2">{
                end = len(list)
        }</span>

        <span class="cov4" title="3">return list[filter.Offset:end], total, nil</span>
}

// Update는 Job을 수정합니다
func (r *JobRepository) Update(ctx context.Context, job *domain.Job) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.jobs[job.ID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("job ID '%s'를 찾을 수 없습니다", job.ID)
        }</span>

        // 복사본 저장
        <span class="cov1" title="1">copied := *job
        copied.Extractions = make([]domain.Extraction, len(job.Extractions))
        copy(copied.Extractions, job.Extractions)
        r.jobs[job.ID] = &amp;copied

        return nil</span>
}

// GetLatestVersionByTransportID는 특정 Transport의 최신 Job 버전을 반환합니다
func (r *JobRepository) GetLatestVersionByTransportID(ctx context.Context, transportID string) (int, error) <span class="cov2" title="2">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        maxVersion := 0
        for _, j := range r.jobs </span><span class="cov4" title="3">{
                if j.TransportID == transportID &amp;&amp; j.Version &gt; maxVersion </span><span class="cov4" title="3">{
                        maxVersion = j.Version
                }</span>
        }

        <span class="cov2" title="2">return maxVersion, nil</span>
}

// GetByTransportID는 특정 Transport의 모든 Job을 조회합니다
func (r *JobRepository) GetByTransportID(ctx context.Context, transportID string) ([]domain.Job, error) <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        list := make([]domain.Job, 0)
        for _, j := range r.jobs </span><span class="cov4" title="3">{
                if j.TransportID == transportID </span><span class="cov4" title="3">{
                        list = append(list, *j)
                }</span>
        }

        // 버전 기준 정렬 (최신순)
        <span class="cov1" title="1">sort.Slice(list, func(i, j int) bool </span><span class="cov4" title="3">{
                return list[i].Version &gt; list[j].Version
        }</span>)

        <span class="cov1" title="1">return list, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package memory는 개발 및 테스트용 인메모리 저장소 구현을 제공합니다.
package memory

import (
        "context"
        "fmt"
        "sort"
        "sync"
        "time"

        "oracle-etl/internal/domain"
        "oracle-etl/internal/repository"
)

// TransportRepository는 인메모리 Transport 저장소 구현입니다
type TransportRepository struct {
        mu         sync.RWMutex
        transports map[string]*domain.Transport
}

// NewTransportRepository는 새로운 인메모리 Transport 저장소를 생성합니다
func NewTransportRepository() repository.TransportRepository <span class="cov6" title="6">{
        return &amp;TransportRepository{
                transports: make(map[string]*domain.Transport),
        }
}</span>

// Create는 새로운 Transport를 생성합니다
func (r *TransportRepository) Create(ctx context.Context, transport *domain.Transport) error <span class="cov8" title="11">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.transports[transport.ID]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("transport ID '%s'가 이미 존재합니다", transport.ID)
        }</span>

        // 복사본 저장
        <span class="cov8" title="10">copied := *transport
        r.transports[transport.ID] = &amp;copied

        return nil</span>
}

// GetByID는 ID로 Transport를 조회합니다
func (r *TransportRepository) GetByID(ctx context.Context, id string) (*domain.Transport, error) <span class="cov6" title="5">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        transport, exists := r.transports[id]
        if !exists </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("transport ID '%s'를 찾을 수 없습니다", id)
        }</span>

        // 복사본 반환
        <span class="cov4" title="3">copied := *transport
        return &amp;copied, nil</span>
}

// List는 Transport 목록을 조회합니다
func (r *TransportRepository) List(ctx context.Context, offset, limit int) ([]domain.Transport, int, error) <span class="cov4" title="3">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // 전체 목록을 슬라이스로 변환
        list := make([]domain.Transport, 0, len(r.transports))
        for _, t := range r.transports </span><span class="cov8" title="10">{
                list = append(list, *t)
        }</span>

        // 생성 시간 기준 정렬 (최신순)
        <span class="cov4" title="3">sort.Slice(list, func(i, j int) bool </span><span class="cov10" title="17">{
                return list[i].CreatedAt.After(list[j].CreatedAt)
        }</span>)

        <span class="cov4" title="3">total := len(list)

        // offset/limit 적용
        if offset &gt;= len(list) </span><span class="cov1" title="1">{
                return []domain.Transport{}, total, nil
        }</span>

        <span class="cov3" title="2">end := offset + limit
        if end &gt; len(list) </span><span class="cov1" title="1">{
                end = len(list)
        }</span>

        <span class="cov3" title="2">return list[offset:end], total, nil</span>
}

// Update는 Transport를 수정합니다
func (r *TransportRepository) Update(ctx context.Context, transport *domain.Transport) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.transports[transport.ID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("transport ID '%s'를 찾을 수 없습니다", transport.ID)
        }</span>

        // UpdatedAt 갱신
        <span class="cov1" title="1">transport.UpdatedAt = time.Now().UTC()

        // 복사본 저장
        copied := *transport
        r.transports[transport.ID] = &amp;copied

        return nil</span>
}

// Delete는 Transport를 삭제합니다
func (r *TransportRepository) Delete(ctx context.Context, id string) error <span class="cov3" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.transports[id]; !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("transport ID '%s'를 찾을 수 없습니다", id)
        }</span>

        <span class="cov1" title="1">delete(r.transports, id)
        return nil</span>
}

// UpdateStatus는 Transport 상태를 변경합니다
func (r *TransportRepository) UpdateStatus(ctx context.Context, id string, status domain.TransportStatus) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        transport, exists := r.transports[id]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("transport ID '%s'를 찾을 수 없습니다", id)
        }</span>

        <span class="cov1" title="1">transport.Status = status
        transport.UpdatedAt = time.Now().UTC()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package resilience는 시스템 복원력을 위한 패턴을 제공합니다.
// M7-03: Circuit Breaker
package resilience

import (
        "errors"
        "sync"
        "time"
)

// ErrCircuitOpen은 Circuit Breaker가 열려있을 때 반환되는 에러입니다
var ErrCircuitOpen = errors.New("circuit breaker is open")

// State는 Circuit Breaker의 상태를 나타냅니다
type State int

const (
        // StateClosed는 정상 상태 (요청 허용)
        StateClosed State = iota
        // StateOpen은 차단 상태 (요청 거부)
        StateOpen
        // StateHalfOpen은 테스트 상태 (일부 요청 허용)
        StateHalfOpen
)

// String은 State를 문자열로 변환합니다
func (s State) String() string <span class="cov3" title="3">{
        switch s </span>{
        case StateClosed:<span class="cov1" title="1">
                return "closed"</span>
        case StateOpen:<span class="cov1" title="1">
                return "open"</span>
        case StateHalfOpen:<span class="cov1" title="1">
                return "half-open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// CircuitConfig는 Circuit Breaker 설정입니다
type CircuitConfig struct {
        // FailureThreshold는 Open 상태로 전환하기 위한 연속 실패 횟수
        FailureThreshold int
        // SuccessThreshold는 Closed 상태로 전환하기 위한 연속 성공 횟수
        SuccessThreshold int
        // Timeout은 Open 상태에서 Half-Open으로 전환하기까지의 대기 시간
        Timeout time.Duration
}

// DefaultCircuitConfig는 기본 Circuit Breaker 설정을 반환합니다
func DefaultCircuitConfig() CircuitConfig <span class="cov3" title="3">{
        return CircuitConfig{
                FailureThreshold: 5,
                SuccessThreshold: 3,
                Timeout:          30 * time.Second,
        }
}</span>

// CircuitMetrics는 Circuit Breaker 메트릭입니다
type CircuitMetrics struct {
        TotalRequests int64 // 총 요청 수
        Successes     int64 // 성공 수
        Failures      int64 // 실패 수
        Rejections    int64 // 거부 수 (Open 상태에서)
}

// CircuitBreaker는 Circuit Breaker 패턴을 구현합니다
type CircuitBreaker struct {
        mu sync.RWMutex

        config CircuitConfig
        state  State

        failures  int // 연속 실패 횟수
        successes int // 연속 성공 횟수 (Half-Open 상태에서)

        lastFailure time.Time // 마지막 실패 시간

        // 메트릭
        totalRequests int64
        totalSuccesses int64
        totalFailures int64
        totalRejections int64
}

// NewCircuitBreaker는 새로운 Circuit Breaker를 생성합니다
func NewCircuitBreaker(config CircuitConfig) *CircuitBreaker <span class="cov5" title="10">{
        return &amp;CircuitBreaker{
                config: config,
                state:  StateClosed,
        }
}</span>

// State는 현재 Circuit Breaker 상태를 반환합니다
func (cb *CircuitBreaker) State() State <span class="cov5" title="10">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        // Open 상태에서 타임아웃 확인
        if cb.state == StateOpen </span><span class="cov3" title="3">{
                if time.Since(cb.lastFailure) &gt;= cb.config.Timeout </span><span class="cov0" title="0">{
                        return StateHalfOpen
                }</span>
        }

        <span class="cov5" title="10">return cb.state</span>
}

// Execute는 주어진 함수를 Circuit Breaker로 보호하여 실행합니다
func (cb *CircuitBreaker) Execute(fn func() error) error <span class="cov10" title="121">{
        cb.mu.Lock()

        // Open 상태 확인 및 타임아웃 처리
        if cb.state == StateOpen </span><span class="cov3" title="4">{
                if time.Since(cb.lastFailure) &gt;= cb.config.Timeout </span><span class="cov3" title="3">{
                        // Half-Open으로 전환
                        cb.state = StateHalfOpen
                        cb.successes = 0
                }</span> else<span class="cov1" title="1"> {
                        // 여전히 Open - 요청 거부
                        cb.totalRejections++
                        cb.mu.Unlock()
                        return ErrCircuitOpen
                }</span>
        }

        <span class="cov9" title="120">cb.totalRequests++
        cb.mu.Unlock()

        // 함수 실행
        err := fn()

        cb.mu.Lock()
        defer cb.mu.Unlock()

        if err != nil </span><span class="cov8" title="63">{
                cb.onFailure()
        }</span> else<span class="cov8" title="57"> {
                cb.onSuccess()
        }</span>

        <span class="cov9" title="120">return err</span>
}

// onSuccess는 성공 시 호출됩니다 (락 보유 상태)
func (cb *CircuitBreaker) onSuccess() <span class="cov8" title="57">{
        cb.totalSuccesses++
        cb.failures = 0 // 연속 실패 리셋

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="54"></span>
                // Closed 상태에서 성공 - 상태 유지
        case StateHalfOpen:<span class="cov3" title="3">
                cb.successes++
                if cb.successes &gt;= cb.config.SuccessThreshold </span><span class="cov2" title="2">{
                        // 충분한 성공 - Closed로 전환
                        cb.state = StateClosed
                        cb.successes = 0
                }</span>
        }
}

// onFailure는 실패 시 호출됩니다 (락 보유 상태)
func (cb *CircuitBreaker) onFailure() <span class="cov8" title="63">{
        cb.totalFailures++
        cb.failures++
        cb.lastFailure = time.Now()

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="62">
                if cb.failures &gt;= cb.config.FailureThreshold </span><span class="cov4" title="5">{
                        // 임계값 초과 - Open으로 전환
                        cb.state = StateOpen
                }</span>
        case StateHalfOpen:<span class="cov1" title="1">
                // Half-Open에서 실패 - 다시 Open으로
                cb.state = StateOpen
                cb.successes = 0</span>
        }
}

// Metrics는 Circuit Breaker 메트릭을 반환합니다
func (cb *CircuitBreaker) Metrics() *CircuitMetrics <span class="cov1" title="1">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        return &amp;CircuitMetrics{
                TotalRequests: cb.totalRequests,
                Successes:     cb.totalSuccesses,
                Failures:      cb.totalFailures,
                Rejections:    cb.totalRejections,
        }
}</span>

// Reset은 Circuit Breaker를 초기 상태로 리셋합니다
func (cb *CircuitBreaker) Reset() <span class="cov0" title="0">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.state = StateClosed
        cb.failures = 0
        cb.successes = 0
        cb.totalRequests = 0
        cb.totalSuccesses = 0
        cb.totalFailures = 0
        cb.totalRejections = 0
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package resilience는 시스템 복원력을 위한 패턴을 제공합니다.
// M7-02: Retry with Exponential Backoff
package resilience

import (
        "context"
        "time"
)

// RetryConfig는 재시도 설정을 정의합니다
type RetryConfig struct {
        // MaxRetries는 최대 시도 횟수입니다 (1 = 재시도 없음)
        MaxRetries int
        // InitialDelay는 첫 재시도 전 대기 시간입니다
        InitialDelay time.Duration
        // MaxDelay는 최대 대기 시간입니다
        MaxDelay time.Duration
        // Multiplier는 지수 백오프 배수입니다
        Multiplier float64
        // RetryableFunc은 에러가 재시도 가능한지 판단하는 함수입니다
        // nil이면 모든 에러가 재시도 가능으로 간주됩니다
        RetryableFunc func(error) bool
}

// DefaultRetryConfig는 기본 재시도 설정을 반환합니다
func DefaultRetryConfig() RetryConfig <span class="cov4" title="3">{
        return RetryConfig{
                MaxRetries:    3,
                InitialDelay:  1 * time.Second,
                MaxDelay:      30 * time.Second,
                Multiplier:    2.0,
                RetryableFunc: nil, // 모든 에러 재시도
        }
}</span>

// Retry는 주어진 함수를 설정에 따라 재시도합니다
func Retry(ctx context.Context, cfg RetryConfig, fn func() error) error <span class="cov7" title="8">{
        var lastErr error
        delay := cfg.InitialDelay

        for attempt := 0; attempt &lt; cfg.MaxRetries; attempt++ </span><span class="cov10" title="19">{
                // 컨텍스트 취소 확인
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if lastErr != nil </span><span class="cov0" title="0">{
                                return lastErr
                        }</span>
                        <span class="cov0" title="0">return ctx.Err()</span>
                default:<span class="cov10" title="19"></span>
                }

                // 함수 실행
                <span class="cov10" title="19">lastErr = fn()
                if lastErr == nil </span><span class="cov3" title="2">{
                        return nil // 성공
                }</span>

                // 재시도 가능 여부 확인
                <span class="cov9" title="17">if cfg.RetryableFunc != nil &amp;&amp; !cfg.RetryableFunc(lastErr) </span><span class="cov1" title="1">{
                        return lastErr // 재시도 불가능한 에러
                }</span>

                // 마지막 시도였으면 대기 없이 반환
                <span class="cov9" title="16">if attempt == cfg.MaxRetries-1 </span><span class="cov5" title="4">{
                        break</span>
                }

                // 지수 백오프 대기
                <span class="cov8" title="12">select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return lastErr</span>
                case &lt;-time.After(delay):<span class="cov8" title="11"></span>
                }

                // 다음 대기 시간 계산
                <span class="cov8" title="11">delay = time.Duration(float64(delay) * cfg.Multiplier)
                if delay &gt; cfg.MaxDelay </span><span class="cov5" title="4">{
                        delay = cfg.MaxDelay
                }</span>
        }

        <span class="cov5" title="4">return lastErr</span>
}

// RetryWithResult는 결과를 반환하는 함수를 재시도합니다
func RetryWithResult[T any](ctx context.Context, cfg RetryConfig, fn func() (T, error)) (T, error) <span class="cov4" title="3">{
        var result T
        var lastErr error
        delay := cfg.InitialDelay

        for attempt := 0; attempt &lt; cfg.MaxRetries; attempt++ </span><span class="cov6" title="6">{
                // 컨텍스트 취소 확인
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if lastErr != nil </span><span class="cov0" title="0">{
                                return result, lastErr
                        }</span>
                        <span class="cov0" title="0">return result, ctx.Err()</span>
                default:<span class="cov6" title="6"></span>
                }

                // 함수 실행
                <span class="cov6" title="6">result, lastErr = fn()
                if lastErr == nil </span><span class="cov3" title="2">{
                        return result, nil // 성공
                }</span>

                // 재시도 가능 여부 확인
                <span class="cov5" title="4">if cfg.RetryableFunc != nil &amp;&amp; !cfg.RetryableFunc(lastErr) </span><span class="cov0" title="0">{
                        return result, lastErr // 재시도 불가능한 에러
                }</span>

                // 마지막 시도였으면 대기 없이 반환
                <span class="cov5" title="4">if attempt == cfg.MaxRetries-1 </span><span class="cov1" title="1">{
                        break</span>
                }

                // 지수 백오프 대기
                <span class="cov4" title="3">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return result, lastErr</span>
                case &lt;-time.After(delay):<span class="cov4" title="3"></span>
                }

                // 다음 대기 시간 계산
                <span class="cov4" title="3">delay = time.Duration(float64(delay) * cfg.Multiplier)
                if delay &gt; cfg.MaxDelay </span><span class="cov0" title="0">{
                        delay = cfg.MaxDelay
                }</span>
        }

        <span class="cov1" title="1">return result, lastErr</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package resilience는 시스템 복원력을 위한 패턴을 제공합니다.
// M7-04: Graceful Shutdown
package resilience

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
)

// CleanupFunc는 정리 함수 타입입니다
type CleanupFunc func(ctx context.Context) error

// cleanupEntry는 정리 함수 항목입니다
type cleanupEntry struct {
        name string
        fn   CleanupFunc
}

// GracefulShutdown은 우아한 종료를 관리합니다
type GracefulShutdown struct {
        mu sync.Mutex

        shuttingDown atomic.Bool
        done         chan struct{}
        cleanups     []cleanupEntry
        inFlight     atomic.Int32

        // 한 번만 정리 실행을 보장
        cleanupOnce sync.Once
        cleanupDone chan struct{}
}

// NewGracefulShutdown은 새로운 GracefulShutdown을 생성합니다
func NewGracefulShutdown() *GracefulShutdown <span class="cov2" title="9">{
        return &amp;GracefulShutdown{
                done:        make(chan struct{}),
                cleanups:    make([]cleanupEntry, 0),
                cleanupDone: make(chan struct{}),
        }
}</span>

// RegisterCleanup은 정리 함수를 등록합니다
// 등록된 순서의 역순으로 실행됩니다 (LIFO)
func (gs *GracefulShutdown) RegisterCleanup(name string, fn CleanupFunc) <span class="cov2" title="6">{
        gs.mu.Lock()
        defer gs.mu.Unlock()

        gs.cleanups = append(gs.cleanups, cleanupEntry{
                name: name,
                fn:   fn,
        })
}</span>

// Trigger는 종료를 시작합니다
func (gs *GracefulShutdown) Trigger() <span class="cov2" title="9">{
        if gs.shuttingDown.CompareAndSwap(false, true) </span><span class="cov2" title="7">{
                close(gs.done)
        }</span>
}

// IsShuttingDown은 종료 중인지 확인합니다
func (gs *GracefulShutdown) IsShuttingDown() bool <span class="cov1" title="2">{
        return gs.shuttingDown.Load()
}</span>

// Done은 종료 신호를 받을 채널을 반환합니다
func (gs *GracefulShutdown) Done() &lt;-chan struct{} <span class="cov1" title="1">{
        return gs.done
}</span>

// AddInFlight는 진행 중인 요청을 추가합니다
func (gs *GracefulShutdown) AddInFlight() <span class="cov1" title="3">{
        gs.inFlight.Add(1)
}</span>

// DoneInFlight는 진행 중인 요청 완료를 표시합니다
func (gs *GracefulShutdown) DoneInFlight() <span class="cov1" title="2">{
        gs.inFlight.Add(-1)
}</span>

// InFlightCount는 진행 중인 요청 수를 반환합니다
func (gs *GracefulShutdown) InFlightCount() int32 <span class="cov1" title="2">{
        return gs.inFlight.Load()
}</span>

// Wait는 모든 정리 작업이 완료될 때까지 대기합니다
func (gs *GracefulShutdown) Wait(ctx context.Context) error <span class="cov2" title="6">{
        // 이미 정리 완료된 경우
        select </span>{
        case &lt;-gs.cleanupDone:<span class="cov1" title="1">
                return nil</span>
        default:<span class="cov2" title="5"></span>
        }

        <span class="cov2" title="5">var cleanupErr error

        gs.cleanupOnce.Do(func() </span><span class="cov2" title="5">{
                defer close(gs.cleanupDone)

                // 진행 중인 요청 완료 대기
                cleanupErr = gs.waitForInFlight(ctx)
                if cleanupErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // 정리 함수 역순 실행
                <span class="cov2" title="5">cleanupErr = gs.runCleanups(ctx)</span>
        })

        // 다른 고루틴이 정리 중인 경우 완료 대기
        <span class="cov2" title="5">select </span>{
        case &lt;-gs.cleanupDone:<span class="cov2" title="5">
                return cleanupErr</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

// waitForInFlight는 진행 중인 요청이 완료될 때까지 대기합니다
func (gs *GracefulShutdown) waitForInFlight(ctx context.Context) error <span class="cov2" title="5">{
        for gs.inFlight.Load() &gt; 0 </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-awaitZero(&amp;gs.inFlight):<span class="cov1" title="1">
                        return nil</span>
                }
        }
        <span class="cov1" title="4">return nil</span>
}

// awaitZero는 카운터가 0이 될 때까지 대기하는 채널을 반환합니다
func awaitZero(counter *atomic.Int32) &lt;-chan struct{} <span class="cov1" title="1">{
        done := make(chan struct{})
        go func() </span><span class="cov1" title="1">{
                for counter.Load() &gt; 0 </span>{<span class="cov10" title="291014">
                        // 짧은 폴링 (실제 구현에서는 조건 변수 사용 권장)
                }</span>
                <span class="cov1" title="1">close(done)</span>
        }()
        <span class="cov1" title="1">return done</span>
}

// runCleanups는 등록된 정리 함수를 역순으로 실행합니다
func (gs *GracefulShutdown) runCleanups(ctx context.Context) error <span class="cov2" title="5">{
        gs.mu.Lock()
        cleanups := make([]cleanupEntry, len(gs.cleanups))
        copy(cleanups, gs.cleanups)
        gs.mu.Unlock()

        var errs []error

        // 역순 실행 (LIFO)
        for i := len(cleanups) - 1; i &gt;= 0; i-- </span><span class="cov2" title="6">{
                entry := cleanups[i]

                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("cleanup interrupted: %w", ctx.Err())</span>
                default:<span class="cov2" title="6"></span>
                }

                <span class="cov2" title="6">if err := entry.fn(ctx); err != nil </span><span class="cov1" title="1">{
                        errs = append(errs, fmt.Errorf("%s: %w", entry.name, err))
                }</span>
        }

        <span class="cov2" title="5">if len(errs) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cleanup errors: %v", errs)
        }</span>

        <span class="cov1" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package usecase는 비즈니스 로직을 구현하는 서비스 레이어입니다.
package usecase

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"

        "oracle-etl/internal/domain"
        "oracle-etl/internal/repository"
)

// JobService는 Job 비즈니스 로직을 처리합니다
type JobService struct {
        jobRepo       repository.JobRepository
        transportRepo repository.TransportRepository
}

// NewJobService는 새로운 JobService를 생성합니다
func NewJobService(jobRepo repository.JobRepository, transportRepo repository.TransportRepository) *JobService <span class="cov7" title="9">{
        return &amp;JobService{
                jobRepo:       jobRepo,
                transportRepo: transportRepo,
        }
}</span>

// CreateJob은 새로운 Job을 생성합니다
func (s *JobService) CreateJob(ctx context.Context, transportID string) (*domain.Job, error) <span class="cov10" title="19">{
        // Transport 존재 여부 확인
        _, err := s.transportRepo.GetByID(ctx, transportID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transport를 찾을 수 없습니다: %w", err)
        }</span>

        // 최신 버전 조회
        <span class="cov9" title="18">latestVersion, err := s.jobRepo.GetLatestVersionByTransportID(ctx, transportID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("최신 버전 조회 실패: %w", err)
        }</span>

        // 새 버전
        <span class="cov9" title="18">newVersion := latestVersion + 1

        // Job ID 생성
        now := time.Now().UTC()
        randomPart := uuid.New().String()[:8]
        jobID := domain.GenerateJobID(now, randomPart)

        // Job 엔티티 생성
        job := domain.NewJob(jobID, transportID, newVersion)

        // 저장
        if err := s.jobRepo.Create(ctx, job); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("job 생성 실패: %w", err)
        }</span>

        <span class="cov9" title="18">return job, nil</span>
}

// GetByID는 ID로 Job을 조회합니다
func (s *JobService) GetByID(ctx context.Context, id string) (*domain.Job, error) <span class="cov5" title="4">{
        return s.jobRepo.GetByID(ctx, id)
}</span>

// List는 필터에 따라 Job 목록을 조회합니다
func (s *JobService) List(ctx context.Context, filter domain.JobListFilter) (*domain.JobListResponse, error) <span class="cov3" title="2">{
        if filter.Limit &lt;= 0 </span><span class="cov0" title="0">{
                filter.Limit = 20
        }</span>
        <span class="cov3" title="2">if filter.Offset &lt; 0 </span><span class="cov0" title="0">{
                filter.Offset = 0
        }</span>

        <span class="cov3" title="2">jobs, total, err := s.jobRepo.List(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return &amp;domain.JobListResponse{
                Jobs:   jobs,
                Total:  total,
                Offset: filter.Offset,
                Limit:  filter.Limit,
        }, nil</span>
}

// StartJob은 Job을 시작 상태로 변경합니다
func (s *JobService) StartJob(ctx context.Context, jobID string) error <span class="cov4" title="3">{
        job, err := s.jobRepo.GetByID(ctx, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">job.Start()

        return s.jobRepo.Update(ctx, job)</span>
}

// CompleteJob은 Job을 완료 상태로 변경합니다
func (s *JobService) CompleteJob(ctx context.Context, jobID string) error <span class="cov1" title="1">{
        job, err := s.jobRepo.GetByID(ctx, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">job.Complete()

        return s.jobRepo.Update(ctx, job)</span>
}

// FailJob은 Job을 실패 상태로 변경합니다
func (s *JobService) FailJob(ctx context.Context, jobID string, errMsg string) error <span class="cov1" title="1">{
        job, err := s.jobRepo.GetByID(ctx, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">job.Fail(errors.New(errMsg))

        return s.jobRepo.Update(ctx, job)</span>
}

// CancelJob은 Job을 취소 상태로 변경합니다
func (s *JobService) CancelJob(ctx context.Context, jobID string) error <span class="cov0" title="0">{
        job, err := s.jobRepo.GetByID(ctx, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">job.Cancel()

        return s.jobRepo.Update(ctx, job)</span>
}

// UpdateJob은 Job을 업데이트합니다
func (s *JobService) UpdateJob(ctx context.Context, job *domain.Job) error <span class="cov0" title="0">{
        return s.jobRepo.Update(ctx, job)
}</span>

// GetJobsByTransportID는 특정 Transport의 모든 Job을 조회합니다
func (s *JobService) GetJobsByTransportID(ctx context.Context, transportID string) ([]domain.Job, error) <span class="cov0" title="0">{
        return s.jobRepo.GetByTransportID(ctx, transportID)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package usecase는 비즈니스 로직을 구현하는 서비스 레이어입니다.
package usecase

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "oracle-etl/internal/adapter/gcs"
        "oracle-etl/internal/adapter/oracle"
        "oracle-etl/internal/adapter/sse"
        "oracle-etl/internal/domain"
        "oracle-etl/pkg/buffer"
        "oracle-etl/pkg/pool"
)

// ExecutionPlan은 병렬 추출 실행 계획을 정의합니다
type ExecutionPlan struct {
        TransportID  string         // Transport ID
        JobID        string         // Job ID
        JobVersion   string         // Job 버전 (v001, v002, ...)
        Tables       []string       // 추출할 테이블 목록
        Concurrency  int            // 동시 실행 수 (0이면 기본값)
        Owner        string         // 스키마 소유자
        BufferConfig *buffer.Config // 버퍼 설정 (nil이면 기본값)
}

// Validate는 ExecutionPlan의 유효성을 검사합니다
func (p *ExecutionPlan) Validate() error <span class="cov6" title="9">{
        if p.TransportID == "" </span><span class="cov1" title="1">{
                return errors.New("TransportID는 필수입니다")
        }</span>
        <span class="cov6" title="8">if len(p.Tables) == 0 </span><span class="cov1" title="1">{
                return errors.New("최소 1개 이상의 테이블이 필요합니다")
        }</span>
        <span class="cov6" title="7">return nil</span>
}

// EffectiveConcurrency는 실제 사용할 동시 실행 수를 반환합니다
func (p *ExecutionPlan) EffectiveConcurrency() int <span class="cov6" title="9">{
        if p.Concurrency &lt;= 0 </span><span class="cov2" title="2">{
                return buffer.DefaultParallelism
        }</span>
        <span class="cov6" title="7">if p.Concurrency &gt; buffer.MaxParallelism </span><span class="cov1" title="1">{
                return buffer.MaxParallelism
        }</span>
        <span class="cov5" title="6">return p.Concurrency</span>
}

// EffectiveBufferConfig는 실제 사용할 버퍼 설정을 반환합니다
func (p *ExecutionPlan) EffectiveBufferConfig() buffer.Config <span class="cov6" title="7">{
        if p.BufferConfig != nil </span><span class="cov2" title="2">{
                return *p.BufferConfig
        }</span>
        <span class="cov5" title="5">return buffer.DefaultConfig()</span>
}

// TableResult는 단일 테이블 추출 결과입니다
type TableResult struct {
        TableName   string        // 테이블 이름
        RowCount    int64         // 처리된 row 수
        ByteCount   int64         // 전송된 바이트 수
        StartTime   time.Time     // 시작 시간
        EndTime     time.Time     // 종료 시간
        Duration    time.Duration // 소요 시간
        GCSPath     string        // GCS 경로
        Error       error         // 에러 (있는 경우)
}

// Success는 테이블 추출이 성공했는지 반환합니다
func (r TableResult) Success() bool <span class="cov10" title="28">{
        return r.Error == nil
}</span>

// RowsPerSecond는 초당 처리 row 수를 반환합니다
func (r TableResult) RowsPerSecond() float64 <span class="cov0" title="0">{
        if r.Duration.Seconds() &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(r.RowCount) / r.Duration.Seconds()</span>
}

// ExecutionResult는 전체 실행 결과입니다
type ExecutionResult struct {
        TransportID      string        // Transport ID
        JobID            string        // Job ID
        JobVersion       string        // Job 버전
        TableResults     []TableResult // 테이블별 결과
        TotalRows        int64         // 총 처리 row 수
        TotalBytes       int64         // 총 전송 바이트 수
        SuccessfulTables int           // 성공한 테이블 수
        FailedTables     int           // 실패한 테이블 수
        StartTime        time.Time     // 시작 시간
        EndTime          time.Time     // 종료 시간
}

// Duration은 전체 소요 시간을 반환합니다
func (r *ExecutionResult) Duration() time.Duration <span class="cov6" title="7">{
        return r.EndTime.Sub(r.StartTime)
}</span>

// RowsPerSecond는 초당 처리 row 수를 반환합니다
func (r *ExecutionResult) RowsPerSecond() float64 <span class="cov1" title="1">{
        duration := r.Duration().Seconds()
        if duration &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return float64(r.TotalRows) / duration</span>
}

// Success는 전체 실행이 성공했는지 반환합니다 (부분 실패 없음)
func (r *ExecutionResult) Success() bool <span class="cov0" title="0">{
        return r.FailedTables == 0
}</span>

// ParallelExecutor는 다중 테이블 병렬 추출을 관리합니다
type ParallelExecutor struct {
        oracle      oracle.Repository
        gcs         gcs.Client
        sse         *sse.Broadcaster
        maxWorkers  int
}

// NewParallelExecutor는 새로운 ParallelExecutor를 생성합니다
func NewParallelExecutor(oracleRepo oracle.Repository, gcsClient gcs.Client, sseBroadcaster *sse.Broadcaster, maxWorkers int) *ParallelExecutor <span class="cov6" title="8">{
        if maxWorkers &lt;= 0 </span><span class="cov1" title="1">{
                maxWorkers = buffer.DefaultParallelism
        }</span>
        <span class="cov6" title="8">return &amp;ParallelExecutor{
                oracle:     oracleRepo,
                gcs:        gcsClient,
                sse:        sseBroadcaster,
                maxWorkers: maxWorkers,
        }</span>
}

// MaxWorkers는 최대 워커 수를 반환합니다
func (e *ParallelExecutor) MaxWorkers() int <span class="cov2" title="2">{
        return e.maxWorkers
}</span>

// Execute는 실행 계획에 따라 병렬 추출을 수행합니다
func (e *ParallelExecutor) Execute(ctx context.Context, plan ExecutionPlan) (*ExecutionResult, error) <span class="cov5" title="6">{
        // 컨텍스트 취소 확인
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return nil, ctx.Err()</span>
        default:<span class="cov5" title="5"></span>
        }

        // 유효성 검사
        <span class="cov5" title="5">if err := plan.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("실행 계획 유효성 검사 실패: %w", err)
        }</span>

        <span class="cov5" title="5">result := &amp;ExecutionResult{
                TransportID:  plan.TransportID,
                JobID:        plan.JobID,
                JobVersion:   plan.JobVersion,
                TableResults: make([]TableResult, 0, len(plan.Tables)),
                StartTime:    time.Now(),
        }

        // 워커 풀 생성
        concurrency := plan.EffectiveConcurrency()
        if concurrency &gt; e.maxWorkers </span><span class="cov0" title="0">{
                concurrency = e.maxWorkers
        }</span>

        <span class="cov5" title="5">workerPool := pool.NewWorkerPool(concurrency)
        workerPool.Start(ctx)

        // 버퍼 설정
        bufferConfig := plan.EffectiveBufferConfig()

        // 결과 수집용 채널
        resultCh := make(chan TableResult, len(plan.Tables))
        var wg sync.WaitGroup

        // 작업 제출
        for _, tableName := range plan.Tables </span><span class="cov7" title="13">{
                table := tableName // 클로저용 복사
                wg.Add(1)

                workerPool.Submit(pool.Task{
                        ID:        fmt.Sprintf("%s-%s", plan.JobID, table),
                        TableName: table,
                        Execute: func(taskCtx context.Context) error </span><span class="cov7" title="13">{
                                defer wg.Done()
                                
                                tableResult := e.extractTable(taskCtx, plan, table, bufferConfig)
                                resultCh &lt;- tableResult
                                
                                // SSE 이벤트 발송
                                if e.sse != nil </span><span class="cov7" title="13">{
                                        e.sendTableEvent(plan.TransportID, plan.JobID, tableResult)
                                }</span>
                                
                                <span class="cov7" title="13">return tableResult.Error</span>
                        },
                })
        }

        // 워커 풀 결과 수집 (별도 goroutine에서)
        <span class="cov5" title="5">go func() </span><span class="cov5" title="5">{
                workerPool.Wait()
                close(resultCh)
        }</span>()

        // 결과 수집
        <span class="cov5" title="5">var totalRows, totalBytes int64
        for tableResult := range resultCh </span><span class="cov7" title="13">{
                result.TableResults = append(result.TableResults, tableResult)
                if tableResult.Success() </span><span class="cov7" title="12">{
                        result.SuccessfulTables++
                        atomic.AddInt64(&amp;totalRows, tableResult.RowCount)
                        atomic.AddInt64(&amp;totalBytes, tableResult.ByteCount)
                }</span> else<span class="cov1" title="1"> {
                        result.FailedTables++
                }</span>
        }

        <span class="cov5" title="5">result.TotalRows = totalRows
        result.TotalBytes = totalBytes
        result.EndTime = time.Now()

        // 완료 이벤트 발송
        if e.sse != nil </span><span class="cov5" title="5">{
                e.sendCompleteEvent(result)
        }</span>

        // 부분 실패 시 에러 반환
        <span class="cov5" title="5">if result.FailedTables &gt; 0 </span><span class="cov1" title="1">{
                return result, fmt.Errorf("%d개 테이블 추출 실패", result.FailedTables)
        }</span>

        <span class="cov4" title="4">return result, nil</span>
}

// extractTable은 단일 테이블을 추출합니다
func (e *ParallelExecutor) extractTable(ctx context.Context, plan ExecutionPlan, tableName string, bufferConfig buffer.Config) TableResult <span class="cov7" title="13">{
        result := TableResult{
                TableName: tableName,
                StartTime: time.Now(),
        }

        // 추출 옵션 설정
        opts := domain.ExtractionOptions{
                ChunkSize:      bufferConfig.ChunkSize,
                FetchArraySize: bufferConfig.FetchArraySize,
        }

        var rowCount int64

        // 데이터 추출
        err := e.oracle.StreamTableData(ctx, plan.Owner, tableName, opts, func(chunk *domain.ChunkResult) error </span><span class="cov7" title="12">{
                // 컨텍스트 취소 확인
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov7" title="12"></span>
                }

                <span class="cov7" title="12">atomic.AddInt64(&amp;rowCount, int64(chunk.RowCount))

                // 진행률 이벤트 발송
                if e.sse != nil </span><span class="cov7" title="12">{
                        e.sendProgressEvent(plan.TransportID, plan.JobID, tableName, atomic.LoadInt64(&amp;rowCount))
                }</span>

                <span class="cov7" title="12">return nil</span>
        })

        <span class="cov7" title="13">result.EndTime = time.Now()
        result.Duration = result.EndTime.Sub(result.StartTime)
        result.RowCount = rowCount

        if err != nil </span><span class="cov1" title="1">{
                result.Error = err
        }</span>

        <span class="cov7" title="13">return result</span>
}

// sendProgressEvent는 진행률 이벤트를 발송합니다
func (e *ParallelExecutor) sendProgressEvent(transportID, jobID, tableName string, rowsProcessed int64) <span class="cov7" title="12">{
        if e.sse == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov7" title="12">e.sse.BroadcastProgress(sse.ProgressEvent{
                TransportID:   transportID,
                JobID:         jobID,
                Table:         tableName,
                RowsProcessed: rowsProcessed,
                RowsTotal:     -1, // 총 row 수 알 수 없음
        })</span>
}

// sendTableEvent는 테이블 완료 이벤트를 발송합니다
func (e *ParallelExecutor) sendTableEvent(transportID, jobID string, result TableResult) <span class="cov7" title="13">{
        if e.sse == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov7" title="13">if !result.Success() </span><span class="cov1" title="1">{
                // 에러 이벤트 발송
                e.sse.BroadcastError(sse.ErrorEvent{
                        TransportID: transportID,
                        JobID:       jobID,
                        Table:       result.TableName,
                        Code:        "EXTRACTION_ERROR",
                        Message:     result.Error.Error(),
                })
                return
        }</span>

        // 테이블 완료 이벤트 (상태 이벤트로 발송)
        <span class="cov7" title="12">e.sse.BroadcastStatus(sse.StatusEvent{
                TransportID: transportID,
                JobID:       jobID,
                Status:      sse.StatusCompleted,
                Message:     fmt.Sprintf("테이블 %s 추출 완료: %d rows, %dms", result.TableName, result.RowCount, result.Duration.Milliseconds()),
        })</span>
}

// sendCompleteEvent는 완료 이벤트를 발송합니다
func (e *ParallelExecutor) sendCompleteEvent(result *ExecutionResult) <span class="cov5" title="5">{
        if e.sse == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="5">e.sse.BroadcastComplete(sse.CompleteEvent{
                TransportID:   result.TransportID,
                JobID:         result.JobID,
                TotalRows:     result.TotalRows,
                TotalBytes:    result.TotalBytes,
                DurationMs:    result.Duration().Milliseconds(),
                TablesCount:   result.SuccessfulTables + result.FailedTables,
        })</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package usecase는 비즈니스 로직을 구현하는 서비스 레이어입니다.
package usecase

import (
        "context"

        "github.com/google/uuid"

        "oracle-etl/internal/domain"
        "oracle-etl/internal/repository"
)

// TransportService는 Transport 비즈니스 로직을 처리합니다
type TransportService struct {
        repo repository.TransportRepository
}

// NewTransportService는 새로운 TransportService를 생성합니다
func NewTransportService(repo repository.TransportRepository) *TransportService <span class="cov7" title="6">{
        return &amp;TransportService{
                repo: repo,
        }
}</span>

// Create는 새로운 Transport를 생성합니다
func (s *TransportService) Create(ctx context.Context, req domain.CreateTransportRequest) (*domain.Transport, error) <span class="cov10" title="11">{
        // 유효성 검사
        if err := req.Validate(); err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        // ID 생성
        <span class="cov9" title="9">id := domain.GenerateTransportID(uuid.New().String())

        // Transport 엔티티 생성
        transport := domain.NewTransport(id, req.Name, req.Description, req.Tables)

        // 저장
        if err := s.repo.Create(ctx, transport); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="9">return transport, nil</span>
}

// GetByID는 ID로 Transport를 조회합니다
func (s *TransportService) GetByID(ctx context.Context, id string) (*domain.Transport, error) <span class="cov6" title="4">{
        return s.repo.GetByID(ctx, id)
}</span>

// List는 Transport 목록을 조회합니다
func (s *TransportService) List(ctx context.Context, offset, limit int) (*domain.TransportListResponse, error) <span class="cov3" title="2">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov3" title="2">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov3" title="2">transports, total, err := s.repo.List(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return &amp;domain.TransportListResponse{
                Transports: transports,
                Total:      total,
                Offset:     offset,
                Limit:      limit,
        }, nil</span>
}

// Delete는 Transport를 삭제합니다
func (s *TransportService) Delete(ctx context.Context, id string) error <span class="cov1" title="1">{
        return s.repo.Delete(ctx, id)
}</span>

// UpdateStatus는 Transport 상태를 변경합니다
func (s *TransportService) UpdateStatus(ctx context.Context, id string, status domain.TransportStatus) error <span class="cov0" title="0">{
        return s.repo.UpdateStatus(ctx, id, status)
}</span>

// Update는 Transport를 수정합니다
func (s *TransportService) Update(ctx context.Context, transport *domain.Transport) error <span class="cov0" title="0">{
        return s.repo.Update(ctx, transport)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package buffer는 IO 버퍼 설정 및 최적화를 제공합니다.
// ETL 파이프라인의 성능 최적화를 위한 버퍼 크기 상수와 설정을 정의합니다.
package buffer

import (
        "errors"
        "fmt"
)

// Oracle 관련 버퍼 상수
// plan.md에 정의된 최적 값 기반
const (
        // OracleFetchArraySize는 Oracle에서 한 번에 fetch할 row 수입니다.
        // 라운드트립을 최소화하면서 메모리 효율성을 유지합니다.
        OracleFetchArraySize = 1000

        // OraclePrefetchCount는 Oracle prefetch 버퍼의 row 수입니다.
        OraclePrefetchCount = 1000
)

// IO 관련 버퍼 상수
const (
        // JSONLBufferSize는 JSONL 인코더의 버퍼 크기입니다 (64KB).
        // 작은 쓰기 작업을 버퍼링하여 IO 효율성을 높입니다.
        JSONLBufferSize = 64 * 1024

        // GzipBufferSize는 gzip 압축 버퍼 크기입니다 (32KB).
        GzipBufferSize = 32 * 1024
)

// GCS 관련 상수
const (
        // GCSChunkSize는 GCS resumable upload의 청크 크기입니다 (16MB).
        // GCS 권장 최소 크기이며, 재시작 시 재전송 오버헤드를 최소화합니다.
        GCSChunkSize = 16 * 1024 * 1024

        // GCSMinChunkSize는 GCS upload의 최소 청크 크기입니다 (256KB).
        GCSMinChunkSize = 256 * 1024
)

// ETL 관련 상수
const (
        // DefaultChunkSize는 스트리밍 시 청크당 row 수입니다.
        DefaultChunkSize = 10000

        // DefaultParallelism은 기본 병렬 처리 수입니다.
        DefaultParallelism = 4

        // MaxParallelism은 최대 병렬 처리 수입니다.
        MaxParallelism = 16
)

// Config는 버퍼 및 성능 관련 설정을 나타냅니다
type Config struct {
        // Oracle 설정
        FetchArraySize int // 한 번에 fetch할 row 수
        PrefetchCount  int // prefetch 버퍼 row 수

        // IO 버퍼 설정
        JSONLBufferSize int // JSONL 버퍼 크기 (bytes)
        GzipBufferSize  int // Gzip 버퍼 크기 (bytes)

        // GCS 설정
        GCSChunkSize int // GCS 업로드 청크 크기 (bytes)

        // ETL 설정
        ChunkSize int // 스트리밍 청크 row 수
}

// DefaultConfig는 기본 설정을 반환합니다
// plan.md에 정의된 최적화된 값을 사용합니다
func DefaultConfig() Config <span class="cov10" title="6">{
        return Config{
                FetchArraySize:  OracleFetchArraySize,
                PrefetchCount:   OraclePrefetchCount,
                JSONLBufferSize: JSONLBufferSize,
                GzipBufferSize:  GzipBufferSize,
                GCSChunkSize:    GCSChunkSize,
                ChunkSize:       DefaultChunkSize,
        }
}</span>

// HighPerformanceConfig는 고성능 설정을 반환합니다
// 더 큰 버퍼를 사용하여 처리량을 극대화합니다
func HighPerformanceConfig() Config <span class="cov1" title="1">{
        return Config{
                FetchArraySize:  2000,              // 더 큰 배치
                PrefetchCount:   2000,              // 더 많은 prefetch
                JSONLBufferSize: 128 * 1024,        // 128KB
                GzipBufferSize:  64 * 1024,         // 64KB
                GCSChunkSize:    32 * 1024 * 1024,  // 32MB
                ChunkSize:       20000,             // 더 큰 청크
        }
}</span>

// LowMemoryConfig는 저메모리 설정을 반환합니다
// 메모리 사용량을 최소화하면서 안정적인 처리를 보장합니다
func LowMemoryConfig() Config <span class="cov1" title="1">{
        return Config{
                FetchArraySize:  500,               // 작은 배치
                PrefetchCount:   500,               // 적은 prefetch
                JSONLBufferSize: 32 * 1024,         // 32KB
                GzipBufferSize:  16 * 1024,         // 16KB
                GCSChunkSize:    8 * 1024 * 1024,   // 8MB
                ChunkSize:       5000,              // 작은 청크
        }
}</span>

// Validate는 설정의 유효성을 검사합니다
func (c Config) Validate() error <span class="cov7" title="4">{
        if c.FetchArraySize &lt;= 0 </span><span class="cov1" title="1">{
                return errors.New("FetchArraySize는 양수여야 합니다")
        }</span>
        <span class="cov6" title="3">if c.PrefetchCount &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("PrefetchCount는 양수여야 합니다")
        }</span>
        <span class="cov6" title="3">if c.JSONLBufferSize &lt;= 0 </span><span class="cov1" title="1">{
                return errors.New("JSONLBufferSize는 양수여야 합니다")
        }</span>
        <span class="cov4" title="2">if c.GzipBufferSize &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("GzipBufferSize는 양수여야 합니다")
        }</span>
        <span class="cov4" title="2">if c.GCSChunkSize &lt; GCSMinChunkSize </span><span class="cov1" title="1">{
                return fmt.Errorf("GCSChunkSize는 최소 %d bytes여야 합니다", GCSMinChunkSize)
        }</span>
        <span class="cov1" title="1">if c.ChunkSize &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("ChunkSize는 양수여야 합니다")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// WithFetchArraySize는 FetchArraySize를 설정한 새 Config를 반환합니다
func (c Config) WithFetchArraySize(size int) Config <span class="cov1" title="1">{
        c.FetchArraySize = size
        return c
}</span>

// WithPrefetchCount는 PrefetchCount를 설정한 새 Config를 반환합니다
func (c Config) WithPrefetchCount(count int) Config <span class="cov0" title="0">{
        c.PrefetchCount = count
        return c
}</span>

// WithJSONLBufferSize는 JSONLBufferSize를 설정한 새 Config를 반환합니다
func (c Config) WithJSONLBufferSize(size int) Config <span class="cov1" title="1">{
        c.JSONLBufferSize = size
        return c
}</span>

// WithGzipBufferSize는 GzipBufferSize를 설정한 새 Config를 반환합니다
func (c Config) WithGzipBufferSize(size int) Config <span class="cov0" title="0">{
        c.GzipBufferSize = size
        return c
}</span>

// WithGCSChunkSize는 GCSChunkSize를 설정한 새 Config를 반환합니다
func (c Config) WithGCSChunkSize(size int) Config <span class="cov0" title="0">{
        c.GCSChunkSize = size
        return c
}</span>

// WithChunkSize는 ChunkSize를 설정한 새 Config를 반환합니다
func (c Config) WithChunkSize(size int) Config <span class="cov1" title="1">{
        c.ChunkSize = size
        return c
}</span>

// EstimatedMemoryUsage는 이 설정으로 예상되는 메모리 사용량을 반환합니다
// 단위: bytes
func (c Config) EstimatedMemoryUsage() int64 <span class="cov1" title="1">{
        // 대략적인 메모리 사용량 추정
        // - FetchArraySize * 평균 row 크기 (약 1KB)
        // - JSONL 버퍼
        // - Gzip 버퍼
        // - GCS 업로드 버퍼

        avgRowSize := int64(1024) // 1KB per row 추정

        oracleBuffer := int64(c.FetchArraySize) * avgRowSize
        jsonlBuffer := int64(c.JSONLBufferSize)
        gzipBuffer := int64(c.GzipBufferSize)
        gcsBuffer := int64(c.GCSChunkSize)

        // 안전 마진 (2x)
        total := (oracleBuffer + jsonlBuffer + gzipBuffer + gcsBuffer) * 2

        return total
}</span>

// String은 설정의 문자열 표현을 반환합니다
func (c Config) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Config{FetchArraySize: %d, PrefetchCount: %d, JSONLBufferSize: %dKB, GzipBufferSize: %dKB, GCSChunkSize: %dMB, ChunkSize: %d}",
                c.FetchArraySize,
                c.PrefetchCount,
                c.JSONLBufferSize/1024,
                c.GzipBufferSize/1024,
                c.GCSChunkSize/(1024*1024),
                c.ChunkSize,
        )
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package compress는 데이터 압축 기능을 제공합니다.
// GCS 업로드를 위한 gzip 스트리밍 압축을 지원합니다.
package compress

import (
        "compress/gzip"
        "io"
        "sync/atomic"
)

// GzipWriter는 gzip 압축을 수행하는 io.WriteCloser 래퍼입니다
type GzipWriter interface {
        io.WriteCloser

        // Flush는 버퍼에 남은 데이터를 출력합니다
        Flush() error

        // BytesWritten은 압축 후 기록된 바이트 수를 반환합니다
        BytesWritten() int64

        // BytesRead는 압축 전 입력된 바이트 수를 반환합니다
        BytesRead() int64
}

// gzipWriter는 GzipWriter 인터페이스의 구현체입니다
type gzipWriter struct {
        writer       *gzip.Writer
        countWriter  *countingWriter
        bytesRead    int64
}

// countingWriter는 기록된 바이트 수를 추적하는 io.Writer 래퍼입니다
type countingWriter struct {
        writer       io.Writer
        bytesWritten int64
}

// Write는 io.Writer 인터페이스를 구현합니다
func (cw *countingWriter) Write(p []byte) (n int, err error) <span class="cov10" title="71">{
        n, err = cw.writer.Write(p)
        atomic.AddInt64(&amp;cw.bytesWritten, int64(n))
        return
}</span>

// NewGzipWriter는 새로운 gzip writer를 생성합니다
// 기본 압축 레벨 (BestSpeed와 BestCompression 사이)을 사용합니다
func NewGzipWriter(w io.Writer) GzipWriter <span class="cov6" title="11">{
        return NewGzipWriterLevel(w, gzip.DefaultCompression)
}</span>

// NewGzipWriterLevel은 지정된 압축 레벨로 gzip writer를 생성합니다
// level: gzip.NoCompression, gzip.BestSpeed, gzip.BestCompression, gzip.DefaultCompression
func NewGzipWriterLevel(w io.Writer, level int) GzipWriter <span class="cov6" title="12">{
        countWriter := &amp;countingWriter{
                writer:       w,
                bytesWritten: 0,
        }

        gzWriter, _ := gzip.NewWriterLevel(countWriter, level)

        return &amp;gzipWriter{
                writer:      gzWriter,
                countWriter: countWriter,
                bytesRead:   0,
        }
}</span>

// Write는 데이터를 압축하여 기록합니다
func (g *gzipWriter) Write(p []byte) (n int, err error) <span class="cov6" title="15">{
        n, err = g.writer.Write(p)
        atomic.AddInt64(&amp;g.bytesRead, int64(n))
        return
}</span>

// Flush는 버퍼에 남은 데이터를 출력합니다
func (g *gzipWriter) Flush() error <span class="cov1" title="1">{
        return g.writer.Flush()
}</span>

// Close는 gzip writer를 닫습니다
// 반드시 호출해야 압축이 완료됩니다
func (g *gzipWriter) Close() error <span class="cov6" title="12">{
        return g.writer.Close()
}</span>

// BytesWritten은 압축 후 기록된 바이트 수를 반환합니다
func (g *gzipWriter) BytesWritten() int64 <span class="cov1" title="1">{
        return atomic.LoadInt64(&amp;g.countWriter.bytesWritten)
}</span>

// BytesRead는 압축 전 입력된 바이트 수를 반환합니다
func (g *gzipWriter) BytesRead() int64 <span class="cov1" title="1">{
        return atomic.LoadInt64(&amp;g.bytesRead)
}</span>

// GzipReader는 gzip 압축 해제를 위한 래퍼입니다 (테스트용)
type GzipReader struct {
        reader *gzip.Reader
}

// NewGzipReader는 새로운 gzip reader를 생성합니다
func NewGzipReader(r io.Reader) (*GzipReader, error) <span class="cov0" title="0">{
        gzReader, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;GzipReader{reader: gzReader}, nil</span>
}

// Read는 io.Reader 인터페이스를 구현합니다
func (g *GzipReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return g.reader.Read(p)
}</span>

// Close는 gzip reader를 닫습니다
func (g *GzipReader) Close() error <span class="cov0" title="0">{
        return g.reader.Close()
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package jsonl은 JSON Lines (NDJSON) 인코딩 기능을 제공합니다.
// JSON Lines 형식은 각 줄에 하나의 JSON 객체를 포함하며,
// 스트리밍 처리와 대용량 데이터 처리에 적합합니다.
package jsonl

import (
        "bufio"
        "encoding/json"
        "io"
        "sync/atomic"
)

// Encoder는 JSON Lines 형식으로 데이터를 인코딩하는 인터페이스입니다
type Encoder interface {
        // Encode는 단일 객체를 JSON Lines 형식으로 인코딩합니다
        Encode(v interface{}) error

        // Flush는 버퍼에 남은 데이터를 출력합니다
        Flush() error

        // BytesWritten은 지금까지 기록된 총 바이트 수를 반환합니다
        BytesWritten() int64

        // RowsEncoded는 지금까지 인코딩된 row 수를 반환합니다
        RowsEncoded() int64
}

// encoder는 Encoder 인터페이스의 기본 구현체입니다
type encoder struct {
        writer       *bufio.Writer
        jsonEncoder  *json.Encoder
        bytesWritten int64
        rowsEncoded  int64
        countWriter  *countingWriter
}

// countingWriter는 기록된 바이트 수를 추적하는 io.Writer 래퍼입니다
type countingWriter struct {
        writer       io.Writer
        bytesWritten *int64
}

// Write는 io.Writer 인터페이스를 구현합니다
func (cw *countingWriter) Write(p []byte) (n int, err error) <span class="cov8" title="12">{
        n, err = cw.writer.Write(p)
        atomic.AddInt64(cw.bytesWritten, int64(n))
        return
}</span>

// NewEncoder는 새로운 JSON Lines 인코더를 생성합니다
// writer: 인코딩된 데이터를 기록할 io.Writer
func NewEncoder(w io.Writer) Encoder <span class="cov8" title="13">{
        var bytesWritten int64
        countWriter := &amp;countingWriter{
                writer:       w,
                bytesWritten: &amp;bytesWritten,
        }

        bufWriter := bufio.NewWriterSize(countWriter, 64*1024) // 64KB 버퍼
        jsonEnc := json.NewEncoder(bufWriter)
        jsonEnc.SetEscapeHTML(false) // HTML 이스케이프 비활성화 (성능 향상)

        return &amp;encoder{
                writer:       bufWriter,
                jsonEncoder:  jsonEnc,
                bytesWritten: 0,
                rowsEncoded:  0,
                countWriter:  countWriter,
        }
}</span>

// Encode는 단일 객체를 JSON Lines 형식으로 인코딩합니다
// JSON Lines 형식: 각 객체는 단일 줄에 JSON으로 직렬화되고 개행문자로 구분됩니다
func (e *encoder) Encode(v interface{}) error <span class="cov10" title="21">{
        if err := e.jsonEncoder.Encode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="21">atomic.AddInt64(&amp;e.rowsEncoded, 1)
        return nil</span>
}

// Flush는 버퍼에 남은 데이터를 출력합니다
func (e *encoder) Flush() error <span class="cov8" title="11">{
        return e.writer.Flush()
}</span>

// BytesWritten은 지금까지 기록된 총 바이트 수를 반환합니다
func (e *encoder) BytesWritten() int64 <span class="cov4" title="3">{
        // 버퍼에 아직 있는 데이터도 포함하여 계산
        _ = e.writer.Flush() // 바이트 계산용으로 에러 무시
        return atomic.LoadInt64(e.countWriter.bytesWritten)
}</span>

// RowsEncoded는 지금까지 인코딩된 row 수를 반환합니다
func (e *encoder) RowsEncoded() int64 <span class="cov5" title="4">{
        return atomic.LoadInt64(&amp;e.rowsEncoded)
}</span>

// StreamEncoder는 스트리밍 컨텍스트에서 사용하기 위한 확장 인터페이스입니다
type StreamEncoder interface {
        Encoder

        // EncodeRows는 여러 row를 한 번에 인코딩합니다
        EncodeRows(rows []map[string]interface{}) error

        // Reset은 내부 상태를 초기화합니다 (동일한 writer에서 재사용)
        Reset()
}

// streamEncoder는 StreamEncoder 인터페이스의 구현체입니다
type streamEncoder struct {
        *encoder
}

// NewStreamEncoder는 스트리밍용 JSON Lines 인코더를 생성합니다
func NewStreamEncoder(w io.Writer) StreamEncoder <span class="cov3" title="2">{
        enc := NewEncoder(w).(*encoder)
        return &amp;streamEncoder{encoder: enc}
}</span>

// EncodeRows는 여러 row를 한 번에 인코딩합니다
func (e *streamEncoder) EncodeRows(rows []map[string]interface{}) error <span class="cov1" title="1">{
        for _, row := range rows </span><span class="cov4" title="3">{
                if err := e.Encode(row); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Reset은 카운터를 초기화합니다
func (e *streamEncoder) Reset() <span class="cov1" title="1">{
        atomic.StoreInt64(&amp;e.rowsEncoded, 0)
        atomic.StoreInt64(e.countWriter.bytesWritten, 0)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package pool은 병렬 작업 처리를 위한 worker pool을 제공합니다.
// ETL 파이프라인에서 다중 테이블 동시 추출을 위해 사용됩니다.
package pool

import (
        "context"
        "sync"
        "sync/atomic"
        "time"
)

// Task는 worker pool에서 실행할 작업을 나타냅니다
type Task struct {
        ID        string                              // 작업 고유 ID
        TableName string                              // 처리할 테이블 이름
        Execute   func(ctx context.Context) error    // 실행할 함수
}

// Result는 작업 실행 결과를 나타냅니다
type Result struct {
        TaskID    string        // 작업 ID
        TableName string        // 테이블 이름
        Error     error         // 에러 (있는 경우)
        StartTime time.Time     // 시작 시간
        EndTime   time.Time     // 종료 시간
        Duration  time.Duration // 소요 시간
}

// Success는 작업이 성공했는지 반환합니다
func (r Result) Success() bool <span class="cov2" title="2">{
        return r.Error == nil
}</span>

// WorkerPool은 병렬 작업을 관리하는 워커 풀입니다
type WorkerPool struct {
        workers   int
        taskQueue chan Task
        results   chan Result
        wg        sync.WaitGroup
        ctx       context.Context
        cancel    context.CancelFunc
        started   int32
        taskCount int32
}

// NewWorkerPool은 새로운 WorkerPool을 생성합니다
// workers: 동시에 실행할 worker 수 (최소 1)
func NewWorkerPool(workers int) *WorkerPool <span class="cov6" title="11">{
        if workers &lt;= 0 </span><span class="cov2" title="2">{
                workers = 1
        }</span>

        <span class="cov6" title="11">return &amp;WorkerPool{
                workers:   workers,
                taskQueue: make(chan Task, 1000),  // 버퍼링된 작업 큐
                results:   make(chan Result, 1000), // 버퍼링된 결과 채널
        }</span>
}

// Workers는 워커 수를 반환합니다
func (p *WorkerPool) Workers() int <span class="cov4" title="4">{
        return p.workers
}</span>

// Start는 워커 풀을 시작합니다
func (p *WorkerPool) Start(ctx context.Context) <span class="cov5" title="7">{
        if !atomic.CompareAndSwapInt32(&amp;p.started, 0, 1) </span><span class="cov0" title="0">{
                return // 이미 시작됨
        }</span>

        <span class="cov5" title="7">p.ctx, p.cancel = context.WithCancel(ctx)

        // 워커 시작
        for i := 0; i &lt; p.workers; i++ </span><span class="cov7" title="16">{
                p.wg.Add(1)
                go p.worker(i)
        }</span>
}

// worker는 단일 워커 goroutine입니다
func (p *WorkerPool) worker(id int) <span class="cov7" title="16">{
        defer p.wg.Done()

        for </span><span class="cov10" title="48">{
                select </span>{
                case &lt;-p.ctx.Done():<span class="cov2" title="2">
                        // 컨텍스트 취소 - 남은 작업 처리
                        for </span><span class="cov4" title="4">{
                                select </span>{
                                case task, ok := &lt;-p.taskQueue:<span class="cov4" title="4">
                                        if !ok </span><span class="cov2" title="2">{
                                                return
                                        }</span>
                                        <span class="cov2" title="2">p.executeTask(task)</span>
                                default:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                case task, ok := &lt;-p.taskQueue:<span class="cov9" title="46">
                        if !ok </span><span class="cov7" title="14">{
                                return // 채널 닫힘
                        }</span>
                        <span class="cov9" title="32">p.executeTask(task)</span>
                }
        }
}

// executeTask는 단일 작업을 실행합니다
func (p *WorkerPool) executeTask(task Task) <span class="cov9" title="34">{
        startTime := time.Now()

        // 작업 실행
        var err error
        if task.Execute != nil </span><span class="cov9" title="34">{
                err = task.Execute(p.ctx)
        }</span>

        <span class="cov9" title="34">endTime := time.Now()

        // 결과 전송
        result := Result{
                TaskID:    task.ID,
                TableName: task.TableName,
                Error:     err,
                StartTime: startTime,
                EndTime:   endTime,
                Duration:  endTime.Sub(startTime),
        }

        select </span>{
        case p.results &lt;- result:<span class="cov9" title="34"></span>
        default:<span class="cov0" title="0">
                // 결과 채널이 가득 찬 경우 (비정상적 상황)
                p.results &lt;- result</span> // 블로킹 전송
        }

        <span class="cov9" title="34">atomic.AddInt32(&amp;p.taskCount, -1)</span>
}

// Submit은 새로운 작업을 제출합니다
func (p *WorkerPool) Submit(task Task) <span class="cov9" title="34">{
        atomic.AddInt32(&amp;p.taskCount, 1)
        p.taskQueue &lt;- task
}</span>

// Wait는 모든 작업이 완료될 때까지 기다리고 결과를 반환합니다
func (p *WorkerPool) Wait() []Result <span class="cov5" title="7">{
        // 작업 큐 닫기 (더 이상 새 작업 없음)
        close(p.taskQueue)

        // 모든 워커가 완료될 때까지 대기
        p.wg.Wait()

        // 결과 채널 닫기
        close(p.results)

        // 모든 결과 수집
        var results []Result
        for result := range p.results </span><span class="cov9" title="34">{
                results = append(results, result)
        }</span>

        <span class="cov5" title="7">return results</span>
}

// Stop은 워커 풀을 중지합니다
func (p *WorkerPool) Stop() <span class="cov5" title="7">{
        if p.cancel != nil </span><span class="cov5" title="7">{
                p.cancel()
        }</span>
        <span class="cov5" title="7">atomic.StoreInt32(&amp;p.started, 0)</span>
}

// PendingTasks는 대기 중인 작업 수를 반환합니다
func (p *WorkerPool) PendingTasks() int <span class="cov0" title="0">{
        return int(atomic.LoadInt32(&amp;p.taskCount))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
